



HTTPbis Working Group                                    A. Backman, Ed.
Internet-Draft                                                    Amazon
Intended status: Standards Track                               J. Richer
Expires: 6 June 2020                                                    
                                                               M. Sporny
                                                          Digital Bazaar
                                                         4 December 2019


                         Signing HTTP Messages
               draft-richanna-http-message-signatures-00

Abstract

   This document describes a mechanism for creating, encoding, and
   verifying digital signatures or message authentication codes over
   subsets of elements within HTTP messages.  This mechanism supports
   use cases where the full HTTP message may not be known to the signer,
   and where the message may be transformed (e.g., by intermediaries)
   before reaching the verifier.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 6 June 2020.

Copyright Notice

   Copyright (c) 2019 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components



Backman, et al.            Expires 6 June 2020                  [Page 1]

Internet-Draft            Signing HTTP Messages            December 2019


   extracted from this document must include Simplified BSD License text
   as described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2
     1.1.  Signing Challenges for HTTP . . . . . . . . . . . . . . .   3
     1.2.  Innocuous Transformations . . . . . . . . . . . . . . . .   4
     1.3.  Conventions and Terminology . . . . . . . . . . . . . . .   4
   2.  Definitions . . . . . . . . . . . . . . . . . . . . . . . . .   5
   3.  HTTP Message Signatures . . . . . . . . . . . . . . . . . . .   5
     3.1.  Signature Metadata  . . . . . . . . . . . . . . . . . . .   5
     3.2.  Signature Input Construction  . . . . . . . . . . . . . .   7
     3.3.  Creating a Signature  . . . . . . . . . . . . . . . . . .   9
     3.4.  Verifying a Signature . . . . . . . . . . . . . . . . . .   9
   4.  The 'Signature' HTTP Header . . . . . . . . . . . . . . . . .  10
     4.1.  Signature Parameters  . . . . . . . . . . . . . . . . . .  10
     4.2.  Signature Header  . . . . . . . . . . . . . . . . . . . .  12
       4.2.1.  RSA Example . . . . . . . . . . . . . . . . . . . . .  12
       4.2.2.  HMAC Example  . . . . . . . . . . . . . . . . . . . .  13
   5.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  13
     5.1.  HTTP Signature Algorithms Registry  . . . . . . . . . . .  13
       5.1.1.  Registration Template . . . . . . . . . . . . . . . .  14
       5.1.2.  Initial Contents  . . . . . . . . . . . . . . . . . .  14
   6.  Security Considerations . . . . . . . . . . . . . . . . . . .  16
   7.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  16
     7.1.  Normative References  . . . . . . . . . . . . . . . . . .  16
     7.2.  Informative References  . . . . . . . . . . . . . . . . .  17
   Appendix A.  Extensions . . . . . . . . . . . . . . . . . . . . .  19
   Appendix B.  Test Values  . . . . . . . . . . . . . . . . . . . .  19
     B.1.  Default Test  . . . . . . . . . . . . . . . . . . . . . .  20
     B.2.  Basic Test  . . . . . . . . . . . . . . . . . . . . . . .  21
     B.3.  All Headers Test  . . . . . . . . . . . . . . . . . . . .  21
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  22
   Document History  . . . . . . . . . . . . . . . . . . . . . . . .  22
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  24

1.  Introduction

   This document describes a mechanism for creating, encoding, and
   verifying digital signatures or message authentication codes (MACs)
   over subsets of elements within HTTP messages [RFC7230].  HTTP
   presents particular challenges for digital signatures and MACs, both
   due to its design and popular usage patterns.  The generic mechanism
   presented in this document overcomes these challenges, allowing
   applications built on HTTP to create signatures over those elements
   of HTTP messages that are relevant to the application, such that



Backman, et al.            Expires 6 June 2020                  [Page 2]

Internet-Draft            Signing HTTP Messages            December 2019


   changes to other elements of the message do not prevent verification
   of the signature.

   The mechanism described in this document consists of four parts:

   *  Rules for creating canonical representations of message elements
      for the purpose of signing

   *  Rules for signing a set of these canonical representations

   *  A mechanism for attaching a signature and related metadata to an
      HTTP message

   *  Instructions on how to verify an HTTP message signature

1.1.  Signing Challenges for HTTP

   Digital signatures and MACs are cryptographic tools that can be used
   to provide various security properties, such as message integrity or
   sender authentication.  While several digital signature and MAC
   algorithms exist, they generally share the constraint that any party
   wishing to verify a signature must be able to reconstruct the exact
   byte sequence of the message that was signed.  In cases where the
   signed message and signature are both sent to the verifier (such as
   with JSON Web Signatures (JWS) [RFC7515]), reconstruction is trivial.
   Unfortunately, HTTP explicitly permits transformations that mean we
   cannot assume that a recipient of a message receives the exact byte
   sequence that was transmitted by the original sender.  For example,
   the following types of transformations are allowed by HTTP:

   *  Re-ordering of header fields, provided the order of header fields
      with the same field name is preserved [RFC7230] (Section 3.2.2)

   *  Combination of header fields with the same field name [RFC7230]
      (Section 3.2.2)

   *  Removal of header fields listed in the "Connection" header field
      [RFC7230] (Section 6.1)

   *  Addition of header fields that indicate control options [RFC7230]
      (Section 6.1)

   *  Addition or removal of a transfer coding [RFC7230] (Section 5.7.2)

   *  Addition of header fields such as "Via" ([RFC7230], Section 5.7.1)
      and "Forwarded" ([RFC7239], Section 4)





Backman, et al.            Expires 6 June 2020                  [Page 3]

Internet-Draft            Signing HTTP Messages            December 2019


   Additionally, environments or software libraries may abstract away
   some of the details of HTTP, such that an application using the
   library may not be able to perfectly reconstruct the message.  For
   example:

   *  An application may use an HTTP library that provides abstract
      object representations of HTTP messages, such as the Java HTTP
      Client (https://openjdk.java.net/groups/net/httpclient/
      intro.html).

   *  A JavaScript application making a cross-origin request using the
      Fetch API (https://fetch.spec.whatwg.org/) may not have full
      control or view of the header fields in the actual HTTP request
      transmitted by the user agent.

1.2.  Innocuous Transformations

   The mechanism described in this document is designed to tolerate
   "innocuous" transformations by allowing the signer to specify
   precisely which elements in the message are to be protected, and
   ensuring that transformations that do not alter the value of
   protected elements do not prevent signature verification.
   Specifically, the following list describes transformations that are
   considered innocuous:

   *  Addition or removal of a non-protected header field.

   *  Consolidation of header fields with the same field name.

   *  Reordering of header fields with different names.

   *  Conversion between HTTP/1.x and HTTP/2, or vice-versa.

   *  Changes in casing (e.g., "Origin" to "origin") of header field
      names, request URI scheme or host, or any other case-insensitive
      element.

   *  Changes to the value of a non-protected element.

1.3.  Conventions and Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.





Backman, et al.            Expires 6 June 2020                  [Page 4]

Internet-Draft            Signing HTTP Messages            December 2019


2.  Definitions

   The terms "HTTP message", "HTTP request", "HTTP response", "header
   field", "sender", and "recipient" take their meaning from HTTP
   [RFC7230].

   For brevity, the term "signature" on its own is used in this document
   to refer to both digital signatures and keyed MACs.  Similarly, the
   verb "sign" refers to the generation of either a digital signature or
   keyed MAC over a given input string.  The qualified term "digital
   signature" refers specifically to the output of an asymmetric
   cryptographic signing operation.

   In addition to those listed above, this document uses the following
   terms:

   Signer
      The entity that is generating or has generated an HTTP Message
      Signature.

   Signing Algorithm
      // TODO // // -- AB

   Signing String
      // TODO // // -- AB

   Verifier
      An entity that is verifying or has verified an HTTP Message
      Signature against an HTTP Message.  Note that an HTTP Message
      Signature may be verified by multiple entities, and thus have
      multiple verifiers.

3.  HTTP Message Signatures

   An HTTP Message Signature represents a signature over a subset of
   protocol elements within an HTTP message.  It consists of a set of
   Signature Parameters containing the signature itself along with
   metadata describing how the signature was generated and which
   protocol elements are covered by it.

3.1.  Signature Metadata

   HTTP Message Signatures have the following metadata properties:

   Algorithm
      REQUIRED.  An HTTP Signature Algorithm defined in the IANA HTTP
      Signature Algorithms registry (Section 5.1) defined in this
      document.  It describes the algorithm(s) used to generate the



Backman, et al.            Expires 6 June 2020                  [Page 5]

Internet-Draft            Signing HTTP Messages            December 2019


      signature, and the algorithm(s) required to verify the signature.
      It is expressed as the name assigned to the HTTP Signature
      Algorithm in the registry.

   Creation Time
      REQUIRED.  A timestamp representing the point in time that the
      signature was generated.  It is expressed as an integer
      representing the number of seconds since the Epoch, as defined in
      Section 4.16
      (https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/
      V1_chap04.html#tag_04_16) of [POSIX.1].  Using a Unix timestamp
      simplifies processing and avoids timezone management required by
      specifications such as [RFC3339].  Sub-second precision is not
      supported.

   Covered Elements
      REQUIRED.  An ordered list of identifiers that indicates the
      metadata and message content that is covered by the signature.
      The order affects signature generation and verification, and
      therefore MUST be preserved.

   Expiration Time
      OPTIONAL.  A timestamp representing the point in time at which the
      signature expires.  An expired signature always fails
      verification.  It is expressed as a decimal representing the
      number of seconds since the Epoch, as defined in Section 4.16
      (https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/
      V1_chap04.html#tag_04_16) of [POSIX.1].  Absence of this property
      indicates that the signature does not expire.  Using a Unix
      timestamp simplifies processing and avoid timezone management
      existing in [RFC3339].  Sub-second precision is allowed using
      decimal notation.

   Key Reference
      OPTIONAL.  A string that describes the key material required to
      verify the signature.  The format and semantics of this string are
      out of scope for this document.  Absence of this property
      indicates that verifiers are expected to determine what key
      material to use via some alternative mechanism not defined in this
      document.

      // While we need to allow for flexibility in key specification, //
      leaving it completely undefined hurts interoperability.  We could
      // borrow from JOSE and define "jwk" and "jku" parameters as //
      extensible ways to specify common types of keys. // // -- AB






Backman, et al.            Expires 6 June 2020                  [Page 6]

Internet-Draft            Signing HTTP Messages            December 2019


3.2.  Signature Input Construction

   A signed HTTP message needs to be tolerant of some trivial
   alterations during transmission as it goes through gateways, proxies,
   and other entities.  These changes are often of little consequence
   and very benign, but also often not visible to or detectable by
   either the sender or the recipient.  Simply signing the entire
   message that was transmitted by the sender is therefore not feasible:
   Even very minor changes would result in a signature which cannot be
   verified.

   The signer determines what signature metadata and message content is
   meaningful, and adds corresponding identifiers for each in the
   signature's Covered Elements.  The Covered Elements list is then used
   to construct the intermediate Signature Input, which is what is
   actually signed.

   In order to generate Signature Input, the signer MUST construct and
   use canonicalized values for each identifier in the signature's
   Covered Elements, in the order they occur in that list.  It is out of
   scope for this document to dictate what header fields or other
   information an application will want to enforce, but implementers
   SHOULD at minimum include the "(request-target)" and "(created)"
   identifiers if the signature's Algorithm name does not start with
   "rsa", "hmac", or "ecdsa".  Otherwise, "(request-target)" and "date"
   SHOULD be included in the signature.

   To include the HTTP request target in the signature calculation, use
   the special "(request-target)" identifier.  To include the
   signature's Creation Time, use the special "(created)" identifier.
   To include the signature's Expiration Time, use the special
   "(expires)" identifier.

   The Signature Input is a US-ASCII string created by concatenating
   together entries for each identifier in the Covered Elements list in
   the order they occur in the list, with each entry separated by a
   newline ""\n"".  An identifier's entry is a US-ASCII string
   consisting of the lowercased identifier followed with an ASCII colon
   "":"", an ASCII space "" "", and a canonicalized value.

   *  If the identifier is "(request-target)" its canonicalized value is
      constructed by concatenating the lowercased :method, an ASCII
      space, and the :path pseudo-headers (as specified in HTTP/2
      [RFC7540], Section 8.1.2.3).  Note: For the avoidance of doubt,
      lowercasing only applies to the :method pseudo-header and not to
      the :path pseudo-header.





Backman, et al.            Expires 6 June 2020                  [Page 7]

Internet-Draft            Signing HTTP Messages            December 2019


   *  If the identifier is "(created)" and the signature's "Algorithm"
      name starts with "rsa", "hmac", or "ecdsa" an implementation MUST
      produce an error.  If the signature's Creation Time is undefined,
      an implementation MUST produce an error.  Otherwise, the
      canonicalized value is the signature's Creation Time.

   *  If the identifier is "(expires)" and the signature's Algorithm
      name starts with "rsa", "hmac", or "ecdsa" an implementation MUST
      produce an error.  If the signature does not have an Expiration
      Time, an implementation MUST produce an error.  Otherwise, the
      canonicalized value is the signature's Expiration Time.

   *  If the identifier is a header field name, its canonicalized value
      is the header field's value, stripped of leading and trailing
      whitespace.  If there are multiple instances of the same header
      field, all header field values associated with the header field
      MUST be concatenated, separated by a ASCII comma and an ASCII
      space ",", in the order in which they will appear in the
      transmitted HTTP message.

      If the header value (after removing leading and trailing
      whitespace) is a zero-length string, the signature string line
      correlating with that header will simply be the (lowercased)
      header name, an ASCII colon ":", and an ASCII space "".

      Any other modification to the header field value MUST NOT be made.
      If a header specified in the headers parameter is malformed or
      cannot be matched with a provided header in the message, the
      implementation MUST produce an error.

   *  If value is not the last value then append an ASCII newline "\n".

   To illustrate the rules specified above, assume a Covered Elements
   list with the value of "(request-target) (created) host date cache-
   control x-emptyheader x-example" and the following HTTP message:

   GET /foo HTTP/1.1
   Host: example.org
   Date: Tue, 07 Jun 2014 20:51:35 GMT
   X-Example: Example header
           with some whitespace.
   X-EmptyHeader:
   Cache-Control: max-age=60
   Cache-Control: must-revalidate

   For the HTTP message above, the corresponding Signature Input is:





Backman, et al.            Expires 6 June 2020                  [Page 8]

Internet-Draft            Signing HTTP Messages            December 2019


   (request-target): get /foo
   (created): 1402170695
   host: example.org
   date: Tue, 07 Jun 2014 20:51:35 GMT
   cache-control: max-age=60, must-revalidate
   x-emptyheader:
   x-example: Example header with some whitespace.

3.3.  Creating a Signature

   In order to create a signature, a signer MUST:

   1.  Choose an algorithm and key material to use, and assign the
       signature's Algorithm and Key Reference properties accordingly.

   2.  Create the Signature Input as described in Section 3.2.

   3.  Sign the Signature Input with a chosen key and algorithm, and
       encode the result as a base 64-encoded string.

   For example, assume that the Algorithm is "hs2019" and the key is an
   EdDSA private key.  This would signal to the application that the the
   signing algorithm is Ed25519 as defined in RFC 8032 [RFC8032],
   Section 5.1.  The result of the signature creation algorithm should
   result in a binary string, which is then base 64 encoded and used as
   the signature value.

3.4.  Verifying a Signature

   In order to verify a signature, a verifier MUST:

   1.  Use the received HTTP message and the signature's metadata to
       recreate the Signature Input, using the process described in
       Section 3.2.

   2.  Use the signature's Algorithm and Key Reference with the
       recreated Signing Input to verify the signature value.

   A signature with a Creation Time that is in the future or an
   Expiration Time that is in the past MUST NOT be processed. // This
   wording implies that verifiers are not permitted to account // for
   clock skew during signature verification. // // -- AB

   The verifier MUST ensure that a signature's Algorithm is appropriate
   for the key material the verifier will use to verify the signature.
   If the Algorithm is not appropriate for the key material, the
   signature MUST NOT be processed.




Backman, et al.            Expires 6 June 2020                  [Page 9]

Internet-Draft            Signing HTTP Messages            December 2019


   Note: The application verifying the signature MUST derive the digital
   signature algorithm from the metadata associated with the "keyId" and
   MUST NOT use the value of "algorithm" from the signed message.

   If a header field specified in the signature's Covered Elements is
   absent from the message, the implementation MUST produce an error.
   Similarly, if the Covered Elements list contains an identifier
   corresponding to a metadata property that is undefined (e.g., the
   list contains "expires" but the signature does not have an Expiration
   Time), the implementation MUST produce an error.

   For example, assume that the Algorithm was "hs2019" and the Key
   Reference refers to an EdDSA public key.  This would signal to the
   application that the signing algorithm is Ed25519 as defined in RFC
   8032 [RFC8032], Section 5.1.  The result of the signature
   verification algorithm should result in a successful verification
   unless the message content or signature metadata protected by the
   signature were tampered with in transit.

4.  The 'Signature' HTTP Header

   The "Signature" HTTP Header provides a mechanism to link the headers
   of a message (client request or server response) to a digital
   signature.  By including the "Digest" header with a properly
   formatted digest, the message body can also be linked to the
   signature.  The signature is generated and verified either using a
   shared secret (e.g., HMAC) or public/private keys (e.g., RSA, EC).
   This allows the receiver and/or any intermediate system to
   immediately or later verify the integrity of the message.  When the
   signature is generated with a private key it can also provide a
   measure of non-repudiation, though a full implementation of a non-
   repudiatable statement is beyond the scope of this specification and
   highly dependent on implementation.

4.1.  Signature Parameters

   The following section details the Signature Parameters.

   "algorithm"
      RECOMMENDED.  The "algorithm" parameter contains the signature's
      Algorithm property.  The Algorithm MUST NOT be marked
      "deprecated".  Implementers SHOULD derive the digital signature
      algorithm used by an implementation from the key metadata
      identified by the "keyId" rather than from this field.  If
      "algorithm" is provided and differs from the key metadata
      identified by the "keyId", for example "rsa-sha256" but an EdDSA
      key is identified via "keyId", then an implementation MUST produce
      an error.  Implementers should note that previous versions of the



Backman, et al.            Expires 6 June 2020                 [Page 10]

Internet-Draft            Signing HTTP Messages            December 2019


      "algorithm" parameter did not use the key information to derive
      the digital signature type and thus could be utilized by attackers
      to expose security vulnerabilities.

      // These instructions are confusing.  Punting algorithm //
      identification into "keyId" hurts interoperability, since we //
      aren't defining the syntax or semantics of "keyId".  It also goes
      // against the statement that we _aren't_ defining "keyId"'s //
      semantics, as we are dictating that the signing algorithm must be
      // specified by "keyId" or derivable from it. // // -- AB

   "created"
      RECOMMENDED.  The "created" parameter contains the signature's
      Creation Time property.  If not specified, the signature's
      Creation Time is undefined.  This parameter is useful when signers
      are not capable of controlling the "Date" HTTP Header such as when
      operating in certain web browser environments.

   "expires"
      OPTIONAL.  The "expires" parameter contains the signature's
      Expiration Time property.

   "headers"
      OPTIONAL.  The "headers" parameter contains the signature's
      Covered Elements property, expressed as a string containing a
      quoted list of the identifiers in the list, in the order they
      occur in the list, with a space "" "" between each identifier.  If
      specified, identifiers for header fields SHOULD be lowercased and
      all others MUST be lowercased.  If not specified, implementations
      MUST operate as if the parameter were specified with a single
      value, "(created)", in the list of HTTP headers.  If the Covered
      Elements property is an empty list, this parameter MUST be
      omitted.  Note:

      1.  The list order is important, and MUST be specified in the
          order the HTTP header field-value pairs are concatenated
          together during Signature Input Construction (Section 3.2)
          used during signing and verifying.

      // The name "headers" is misleading, as this parameter will
      contain // entries that are not HTTP header field names (e.g.,
      "(created)"). // // -- AB

      // This needs to be expanded to allow for more fine-grained
      inclusion // of message elements (e.g., method, scheme, authority,
      path, query // string parameters). // // -- AB





Backman, et al.            Expires 6 June 2020                 [Page 11]

Internet-Draft            Signing HTTP Messages            December 2019


   "keyId"
      REQUIRED.  The "keyId" field contains the signature's "Key
      Reference" property.

   "signature"
      REQUIRED.  The "signature" parameter is the signature value,
      expressed as a base 64-encoded string, as described in RFC 4648
      [RFC4648], Section 4.

4.2.  Signature Header

   The sender is expected to transmit a header (as defined in RFC 7230
   [RFC7230], Section 3.2) where the "field-name" is "Signature", and
   the "field-value" contains one or more "auth-param"s (as defined in
   RFC 7235 [RFC7235], Section 4.1) where the "auth-param" parameters
   are parameters defined in Section 4.1.

   If any of parameters are erroneously duplicated in the Signature
   header field value, then the the signature MUST NOT be processed.
   Any parameter that is not recognized by the verifier or that is not
   well-formed MUST be ignored.

   The rest of this section uses the following HTTP request as an
   example.

   POST /foo HTTP/1.1
   Host: example.org
   Date: Tue, 07 Jun 2014 20:51:35 GMT
   Content-Type: application/json
   Digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
   Content-Length: 18

   {"hello": "world"}

   The following sections assume that the "rsa-key-1" keyId provided by
   the signer is an identifier meaningful to the verifier.

4.2.1.  RSA Example

   The signature header and signature would be generated as:

   Signature: keyId="rsa-key-1",algorithm="hs2019",
       created=1402170695, expires=1402170995,
       headers="(request-target) (created) (expires)
           host date digest content-length",
       signature="Base64(RSA-SHA256(signing string))"

   The signer would compose the signing string as:



Backman, et al.            Expires 6 June 2020                 [Page 12]

Internet-Draft            Signing HTTP Messages            December 2019


   (request-target): post /foo\n
   (created): 1402170695
   (expires): 1402170995
   host: example.org\n
   digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=\n
   content-length: 18

   Note that the '\n' symbols above are included to demonstrate where
   the new line character should be inserted.  There is no new line on
   the final line of the signing string.  Each HTTP header above is
   displayed on a new line to provide better readability of the example.

   For an RSA-based signature, the authorization header and signature
   would then be generated as:

   Signature: keyId="rsa-key-1",algorithm="hs2019",created=1402170695,
       headers="(request-target) (created) host digest content-length",
       signature="Base64(RSA-SHA512(signing string))"

4.2.2.  HMAC Example

   For an HMAC-based signature without a list of headers specified, the
   authorization header and signature would be generated as:

   Signature: keyId="hmac-key-1",algorithm="hs2019",created=1402170695,
       headers="(request-target) (created) host digest content-length",
       signature="Base64(HMAC-SHA512(signing string))"

   The only difference between the RSA Example and the HMAC Example is
   the signature algorithm that is used.  The signer would compose the
   signing string in the same way as the RSA Example above:

   (request-target): post /foo\n
   (created): 1402170695
   host: example.org\n
   digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=\n
   content-length: 18

5.  IANA Considerations

5.1.  HTTP Signature Algorithms Registry

   // JSON Web Algorithms (JWA) [RFC7518] already defines an IANA //
   registry for cryptographic algorithms.  What is the justification //
   for defining a new one? // // -- AB

   This document defines HTTP Signature Algorithms, for which IANA is
   asked to create and maintain a new registry titled "HTTP Signature



Backman, et al.            Expires 6 June 2020                 [Page 13]

Internet-Draft            Signing HTTP Messages            December 2019


   Algorithms".  Initial values for this registry are given in
   Section 5.1.2.  Future assignments and modifications to existing
   assignment are to be made through the Expert Review registration
   policy [BCP 26] and shall follow the template presented in
   Section 5.1.1.

5.1.1.  Registration Template

   Algorithm Name
      An identifier for the HTTP Signature Algorithm.  The name MUST be
      an ASCII string consisting only of lower-case characters (""a"" -
      ""z""), digits (""0"" - ""9""), and hyphens (""-""), and SHOULD
      NOT exceed 20 characters in length.  The identifier MUST be unique
      within the context of the registry.

   Status
      A brief text description of the status of the algorithm.  The
      description MUST begin with one of "Active" or "Deprecated", and
      MAY provide further context or explanation as to the reason for
      the status.

   Description
      A description of the algorithm used to sign the signing string
      when generating an HTTP Message Signature, or instructions on how
      to determine that algorithm.  When the description specifies an
      algorithm, it MUST include a reference to the document or
      documents that define the algorithm.

5.1.2.  Initial Contents

   // The references in this section are problematic as many of the //
   specifications that they refer to are too implementation specific, //
   rather than just pointing to the proper signature and hashing //
   specifications.  A better approach might be just specifying the //
   signature and hashing function specifications, leaving //
   implementers to connect the dots (which are not that hard to //
   connect). // // -- MS

   // Initial registry contents should not contain deprecated //
   algorithms. // // -- AB

"hs2019"

   Algorithm Name
      "hs2019"

   Status
      active



Backman, et al.            Expires 6 June 2020                 [Page 14]

Internet-Draft            Signing HTTP Messages            December 2019


   Description
      Derived from metadata associated with "keyId".  Recommend support
      for:

      *  RSASSA-PSS [RFC8017] using SHA-512 [RFC6234]

      *  HMAC [RFC2104] using SHA-512 [RFC6234]

      *  ECDSA using curve P-256 [DSS] and SHA-512 [RFC6234]

      *  Ed25519ph, Ed25519ctx, and Ed25519 [RFC8032]

      // Pushing this into "keyId" without guidance on "keyId"'s format
      // hurts interoperability and contradicts the earlier statement
      that // the structure and semantics of "keyId" are out of scope.
      These // should each be defined as separate algorithms, and the //
      verification steps should require the verifier to confirm that the
      // specified key fits the specified algorithm. // // -- AB

"rsa-sha1"

   Algorithm Name
      "rsa-sha1"

   Status
      Deprecated; SHA-1 not secure.

      // What does "not secure" mean in this context?  Should this even
      be // defined if there are security concerns? // // -- AB

   Description
      RSASSA-PKCS1-v1_5 [RFC8017] using SHA-1 [RFC6234]

"rsa-sha256"

   Algorithm Name
      "rsa-sha256"

   Status
      Deprecated; specifying signature algorithm enables attack vector.

      // What attack vector?  Can we mitigate it by including
      "algorithm" // in the signing string? // // -- AB

   Description
      RSASSA-PKCS1-v1_5 [RFC8017] using SHA-256 [RFC6234]





Backman, et al.            Expires 6 June 2020                 [Page 15]

Internet-Draft            Signing HTTP Messages            December 2019


"hmac-sha256"

   Algorithm Name
      "hmac-sha256"

   Status
      Deprecated; specifying signature algorithm enables attack vector.

      // What attack vector?  Can we mitigate it by including
      "algorithm" // in the signing string? // // -- AB

   Description
      HMAC [RFC2104] using SHA-256 [RFC6234]

"ecdsa-sha256"

   Algorithm Name
      "ecdsa-sha256"

   Status
      Deprecated; specifying signature algorithm enables attack vector.

      // What attack vector?  Can we mitigate it by including
      "algorithm" // in the signing string? // // -- AB

   Description
      ECDSA using curve P-256 [DSS] and SHA-256 [RFC6234]

6.  Security Considerations

   // TODO: need to dive deeper on this section; not sure how much of //
   what's referenced below is actually applicable, or if it covers //
   everything we need to worry about. // // -- AB

   There are a number of security considerations to take into account
   when implementing or utilizing this specification.  A thorough
   security analysis of this protocol, including its strengths and
   weaknesses, can be found in Security Considerations for HTTP
   Signatures [WP-HTTP-Sig-Audit].

7.  References

7.1.  Normative References

   [BCP 26]   Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/info/rfc8126>.



Backman, et al.            Expires 6 June 2020                 [Page 16]

Internet-Draft            Signing HTTP Messages            December 2019


   [DSS]      NIST, "Digital Signature Standard (DSS)", FIPS 186-4,
              DOI 10.6028/NIST.FIPS.186-4, July 2013,
              <https://csrc.nist.gov/publications/detail/fips/186/4/
              final>.

   [POSIX.1]  IEEE and The Open Group, "The Open Group Base
              Specifications Issue 7, 2018 edition", IEEE
              Std 1003.1-2017, 2018,
              <https://pubs.opengroup.org/onlinepubs/9699919799/>.

   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", RFC 2104,
              DOI 10.17487/RFC2104, February 1997,
              <https://www.rfc-editor.org/info/rfc2104>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC4648]  Josefsson, S., "The Base16, Base32, and Base64 Data
              Encodings", RFC 4648, DOI 10.17487/RFC4648, October 2006,
              <https://www.rfc-editor.org/info/rfc4648>.

   [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing",
              RFC 7230, DOI 10.17487/RFC7230, June 2014,
              <https://www.rfc-editor.org/info/rfc7230>.

   [RFC7235]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Authentication", RFC 7235,
              DOI 10.17487/RFC7235, June 2014,
              <https://www.rfc-editor.org/info/rfc7235>.

   [RFC7540]  Belshe, M., Peon, R., and M. Thomson, Ed., "Hypertext
              Transfer Protocol Version 2 (HTTP/2)", RFC 7540,
              DOI 10.17487/RFC7540, May 2015,
              <https://www.rfc-editor.org/info/rfc7540>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

7.2.  Informative References

   [RFC3339]  Klyne, G. and C. Newman, "Date and Time on the Internet:
              Timestamps", RFC 3339, DOI 10.17487/RFC3339, July 2002,
              <https://www.rfc-editor.org/info/rfc3339>.



Backman, et al.            Expires 6 June 2020                 [Page 17]

Internet-Draft            Signing HTTP Messages            December 2019


   [RFC6234]  Eastlake 3rd, D. and T. Hansen, "US Secure Hash Algorithms
              (SHA and SHA-based HMAC and HKDF)", RFC 6234,
              DOI 10.17487/RFC6234, May 2011,
              <https://www.rfc-editor.org/info/rfc6234>.

   [RFC7239]  Petersson, A. and M. Nilsson, "Forwarded HTTP Extension",
              RFC 7239, DOI 10.17487/RFC7239, June 2014,
              <https://www.rfc-editor.org/info/rfc7239>.

   [RFC7515]  Jones, M., Bradley, J., and N. Sakimura, "JSON Web
              Signature (JWS)", RFC 7515, DOI 10.17487/RFC7515, May
              2015, <https://www.rfc-editor.org/info/rfc7515>.

   [RFC7518]  Jones, M., "JSON Web Algorithms (JWA)", RFC 7518,
              DOI 10.17487/RFC7518, May 2015,
              <https://www.rfc-editor.org/info/rfc7518>.

   [RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,
              "PKCS #1: RSA Cryptography Specifications Version 2.2",
              RFC 8017, DOI 10.17487/RFC8017, November 2016,
              <https://www.rfc-editor.org/info/rfc8017>.

   [RFC8032]  Josefsson, S. and I. Liusvaara, "Edwards-Curve Digital
              Signature Algorithm (EdDSA)", RFC 8032,
              DOI 10.17487/RFC8032, January 2017,
              <https://www.rfc-editor.org/info/rfc8032>.

   [WP-HTTP-Sig-Audit]
              Sporny, M., "Security Considerations for HTTP Signatures",
              June 2013, <https://web-payments.org/specs/source/http-
              signatures-audit/>.

   [WP-HTTP-Sig-Nonces]
              Sporny, M., "HTTP Signature Nonces", July 2013,
              <https://web-payments.org/specs/source/http-signature-
              nonces/>.

   [WP-HTTP-Sig-Trailers]
              Sporny, M., "HTTP Signature Trailers", July 2013,
              <https://web-payments.org/specs/source/http-signature-
              trailers/>.










Backman, et al.            Expires 6 June 2020                 [Page 18]

Internet-Draft            Signing HTTP Messages            December 2019


Appendix A.  Extensions

   This specification was designed to be simple, modular, and
   extensible.  There are a number of other specifications that build on
   this one.  For example, the HTTP Signature Nonces
   [WP-HTTP-Sig-Nonces] specification details how to use HTTP Signatures
   over a non-secured channel like HTTP and the HTTP Signature Trailers
   [WP-HTTP-Sig-Trailers] specification explains how to apply HTTP
   Signatures to streaming content.  Developers that desire more
   functionality than this specification provides are urged to ensure
   that an extension specification doesn't already exist before
   implementing a proprietary extension.

   If extensions to this specification are made by adding new Signature
   Parameters, those extension parameters MUST be registered in the
   Signature Authentication Scheme Registry.  The registry will be
   created and maintained at (the suggested URI)
   https://www.iana.org/assignments/http-auth-scheme-signature.

   An example entry in this registry is included below:

   Signature Parameter: nonce
   Reference to specification: [HTTP_AUTH_SIGNATURE_NONCE], Section XYZ.
   Notes (optional): The HTTP Signature Nonces specification details
   how to use HTTP Signatures over a unsecured channel like HTTP.

Appendix B.  Test Values

   WARNING: THESE TEST VECTORS ARE OLD AND POSSIBLY WRONG.  THE NEXT
   VERSION OF THIS SPECIFICATION WILL CONTAIN THE PROPER TEST VECTORS.

   The following test data uses the following RSA 2048-bit keys, which
   we will refer to as "keyId=Test" in the following samples:


















Backman, et al.            Expires 6 June 2020                 [Page 19]

Internet-Draft            Signing HTTP Messages            December 2019


   -----BEGIN PUBLIC KEY-----
   MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCFENGw33yGihy92pDjZQhl0C3
   6rPJj+CvfSC8+q28hxA161QFNUd13wuCTUcq0Qd2qsBe/2hFyc2DCJJg0h1L78+6
   Z4UMR7EOcpfdUE9Hf3m/hs+FUR45uBJeDK1HSFHD8bHKD6kv8FPGfJTotc+2xjJw
   oYi+1hqp1fIekaxsyQIDAQAB
   -----END PUBLIC KEY-----

   -----BEGIN RSA PRIVATE KEY-----
   MIICXgIBAAKBgQDCFENGw33yGihy92pDjZQhl0C36rPJj+CvfSC8+q28hxA161QF
   NUd13wuCTUcq0Qd2qsBe/2hFyc2DCJJg0h1L78+6Z4UMR7EOcpfdUE9Hf3m/hs+F
   UR45uBJeDK1HSFHD8bHKD6kv8FPGfJTotc+2xjJwoYi+1hqp1fIekaxsyQIDAQAB
   AoGBAJR8ZkCUvx5kzv+utdl7T5MnordT1TvoXXJGXK7ZZ+UuvMNUCdN2QPc4sBiA
   QWvLw1cSKt5DsKZ8UETpYPy8pPYnnDEz2dDYiaew9+xEpubyeW2oH4Zx71wqBtOK
   kqwrXa/pzdpiucRRjk6vE6YY7EBBs/g7uanVpGibOVAEsqH1AkEA7DkjVH28WDUg
   f1nqvfn2Kj6CT7nIcE3jGJsZZ7zlZmBmHFDONMLUrXR/Zm3pR5m0tCmBqa5RK95u
   412jt1dPIwJBANJT3v8pnkth48bQo/fKel6uEYyboRtA5/uHuHkZ6FQF7OUkGogc
   mSJluOdc5t6hI1VsLn0QZEjQZMEOWr+wKSMCQQCC4kXJEsHAve77oP6HtG/IiEn7
   kpyUXRNvFsDE0czpJJBvL/aRFUJxuRK91jhjC68sA7NsKMGg5OXb5I5Jj36xAkEA
   gIT7aFOYBFwGgQAQkWNKLvySgKbAZRTeLBacpHMuQdl1DfdntvAyqpAZ0lY0RKmW
   G6aFKaqQfOXKCyWoUiVknQJAXrlgySFci/2ueKlIE1QqIiLSZ8V8OlpFLRnb1pzI
   7U1yQXnTAEFYM560yJlzUpOb1V4cScGd365tiSMvxLOvTA==
   -----END RSA PRIVATE KEY-----

   All examples use this request:

   POST /foo?param=value&pet=dog HTTP/1.1
   Host: example.com
   Date: Sun, 05 Jan 2014 21:31:40 GMT
   Content-Type: application/json
   Digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
   Content-Length: 18

   {"hello": "world"}

B.1.  Default Test

   If a list of headers is not included, the date is the only header
   that is signed by default for rsa-sha256.  The string to sign would
   be:

   date: Sun, 05 Jan 2014 21:31:40 GMT

   The Authorization header would be:

   Authorization: Signature keyId="Test",algorithm="rsa-sha256",
   signature="SjWJWbWN7i0wzBvtPl8rbASWz5xQW6mcJmn+ibttBqtifLN7Sazz
   6m79cNfwwb8DMJ5cou1s7uEGKKCs+FLEEaDV5lp7q25WqS+lavg7T8hc0GppauB
   6hbgEKTwblDHYGEtbGmtdHgVCk9SuS13F0hZ8FD0k/5OxEPXe5WozsbM="



Backman, et al.            Expires 6 June 2020                 [Page 20]

Internet-Draft            Signing HTTP Messages            December 2019


   The Signature header would be:

   Signature: keyId="Test",algorithm="rsa-sha256",
   signature="SjWJWbWN7i0wzBvtPl8rbASWz5xQW6mcJmn+ibttBqtifLN7Sazz
   6m79cNfwwb8DMJ5cou1s7uEGKKCs+FLEEaDV5lp7q25WqS+lavg7T8hc0GppauB
   6hbgEKTwblDHYGEtbGmtdHgVCk9SuS13F0hZ8FD0k/5OxEPXe5WozsbM="

B.2.  Basic Test

   The minimum recommended data to sign is the (request-target), host,
   and date.  In this case, the string to sign would be:

   (request-target): post /foo?param=value&pet=dog
   host: example.com
   date: Sun, 05 Jan 2014 21:31:40 GMT

   The Authorization header would be:

   Authorization: Signature keyId="Test",algorithm="rsa-sha256",
       headers="(request-target) host date",
       signature="qdx+H7PHHDZgy4y/Ahn9Tny9V3GP6YgBPyUXMmoxWtLbHpUnXS
       2mg2+SbrQDMCJypxBLSPQR2aAjn7ndmw2iicw3HMbe8VfEdKFYRqzic+efkb3
       nndiv/x1xSHDJWeSWkx3ButlYSuBskLu6kd9Fswtemr3lgdDEmn04swr2Os0="

B.3.  All Headers Test

   A strong signature including all of the headers and a digest of the
   body of the HTTP request would result in the following signing
   string:

   (request-target): post /foo?param=value&pet=dog
   host: example.com
   date: Sun, 05 Jan 2014 21:31:40 GMT
   content-type: application/json
   digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
   content-length: 18

   The Authorization header would be:

   Authorization: Signature keyId="Test",algorithm="rsa-sha256",
       created=1402170695, expires=1402170699,
       headers="(request-target) (created) (expires)
           host date content-type digest content-length",
       signature="vSdrb+dS3EceC9bcwHSo4MlyKS59iFIrhgYkz8+oVLEEzmYZZvRs
           8rgOp+63LEM3v+MFHB32NfpB2bEKBIvB1q52LaEUHFv120V01IL+TAD48XaER
           ZFukWgHoBTLMhYS2Gb51gWxpeIq8knRmPnYePbF5MOkR0Zkly4zKH7s1dE="

   The Signature header would be:



Backman, et al.            Expires 6 June 2020                 [Page 21]

Internet-Draft            Signing HTTP Messages            December 2019


   Signature: keyId="Test",algorithm="rsa-sha256",
       created=1402170695, expires=1402170699,
       headers="(request-target) (created) (expires)
           host date content-type digest content-length",
       signature="vSdrb+dS3EceC9bcwHSo4MlyKS59iFIrhgYkz8+oVLEEzmYZZvRs
           8rgOp+63LEM3v+MFHB32NfpB2bEKBIvB1q52LaEUHFv120V01IL+TAD48XaER
           ZFukWgHoBTLMhYS2Gb51gWxpeIq8knRmPnYePbF5MOkR0Zkly4zKH7s1dE="

Acknowledgements

   This specification is based on the draft-cavage-http-signatures
   draft.  The editor would like to thank the authors of that draft,
   Mark Cavage and Manu Sporny, for their work on that draft and their
   continuing contributions.

   The editor would also like to thank the following individuals for
   feedback on and implementations of the draft-cavage-http-signatures
   draft (in alphabetical order): Mark Adamcin, Mark Allen, Paul
   Annesley, Karl Boehlmark, Stephane Bortzmeyer, Sarven Capadisli, Liam
   Dennehy, ductm54, Stephen Farrell, Phillip Hallam-Baker, Eric Holmes,
   Andrey Kislyuk, Adam Knight, Dave Lehn, Dave Longley, James H.
   Manger, Ilari Liusvaara, Mark Nottingham, Yoav Nir, Adrian Palmer,
   Lucas Pardue, Roberto Polli, Julian Reschke, Michael Richardson,
   Wojciech Rygielski, Adam Scarr, Cory J.  Slep, Dirk Stein, Henry
   Story, Lukasz Szewc, Chris Webber, and Jeffrey Yasskin

Document History

   This section is to be removed before publishing as an RFC.

   *  *draft-richanna-http-message-signatures*

      -  *-00*

         o  Converted to xml2rfc v3 and reformatted to comply with RFC
            style guides.

         o  Rewrote abstract and introduction to focus on general
            purpose signing and avoid specific use cases.

         o  Added intro sections on challenges with HTTP message
            signing, and listing innocuous transformations that the
            signing mechanism must tolerate.

         o  Added Document History section.

         o  Removed informative intro sections on Signatures in HTTP
            Requests/Responses, as they imply specific use cases.



Backman, et al.            Expires 6 June 2020                 [Page 22]

Internet-Draft            Signing HTTP Messages            December 2019


         o  Moved BCP 14 message under intro section.

         o  Removed "Signature" auth-scheme definition and non-normative
            description of using the "Signature" header field for
            authentication.

         o  Removed "Canonicalization Algorithm" from HTTP Signature
            Algorithms registry entries.

         o  Replaced mentions of ANSI X9.64 with normative references to
            FIPS 186-4.

         o  Combined HTTP Signature Algorithms registry entry algorithm
            fields into a "Description" field.

         o  Revised HTTP Signature Algorithms registry definition.
            Added change control policy and registry template.  Removed
            suggested URI.

         o  Moved normative text related to ambiguous signature
            parameters to Signature header definition.

         o  Added normative reference to RFC 2104 for HMAC.

         o  Added informative reference to RFC 3339.

         o  Added normative reference to POSIX.1 in `created` and
            `expires` parameter definitions.

         o  Added definitions for HTTP-related terms by referencing RFC
            7230.

         o  Added definitions for Signer and Verifier, and placeholder
            entries for Signing Algorithm and Signing String.

         o  Added definition of signature as applying to both digital
            signatures and MACs.

         o  Renamed The Components of a Signature to HTTP Message
            Signatures.  Revised to define message signatures without
            reference to Authorization or Signature headers.

         o  Added Signature Metadata section.  Moved normative
            requirements in Signature Parameters out to appropriate
            places (e.g., signature creation), redefined parameters in
            terms of metadata properties, and moved them to Signature
            header section.




Backman, et al.            Expires 6 June 2020                 [Page 23]

Internet-Draft            Signing HTTP Messages            December 2019


Authors' Addresses

   Annabelle Backman (editor)
   Amazon
   P.O. Box 81226
   Seattle, WA 98108-1226
   United States of America

   Email: richanna@amazon.com
   URI:   https://www.amazon.com/


   Justin Richer

   Email: ietf@justin.richer.org


   Manu Sporny
   Digital Bazaar
   203 Roanoke Street W.
   Blacksburg, VA 24060
   United States of America

   Phone: +1 540 961 4469
   Email: msporny@digitalbazaar.com
   URI:   https://manu.sporny.org/

























Backman, et al.            Expires 6 June 2020                 [Page 24]
