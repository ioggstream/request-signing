



HTTPbis Working Group                                    A. Backman, Ed.
Internet-Draft                                                    Amazon
Intended status: Standards Track                               J. Richer
Expires: 10 June 2020                                                   
                                                               M. Sporny
                                                          Digital Bazaar
                                                         8 December 2019


                         Signing HTTP Messages
               draft-richanna-http-message-signatures-00

Abstract

   This document describes a mechanism for creating, encoding, and
   verifying digital signatures or message authentication codes over
   content within an HTTP message.  This mechanism supports use cases
   where the full HTTP message may not be known to the signer, and where
   the message may be transformed (e.g., by intermediaries) before
   reaching the verifier.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 10 June 2020.

Copyright Notice

   Copyright (c) 2019 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components



Backman, et al.           Expires 10 June 2020                  [Page 1]

Internet-Draft            Signing HTTP Messages            December 2019


   extracted from this document must include Simplified BSD License text
   as described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
     1.1.  Requirements Discussion . . . . . . . . . . . . . . . . .   3
     1.2.  HTTP Message Transformations  . . . . . . . . . . . . . .   4
     1.3.  Safe Transformations  . . . . . . . . . . . . . . . . . .   5
     1.4.  Conventions and Terminology . . . . . . . . . . . . . . .   5
   2.  Identifying and Canonicalizing Content  . . . . . . . . . . .   6
     2.1.  HTTP Header Fields  . . . . . . . . . . . . . . . . . . .   7
     2.2.  Signature Creation Time . . . . . . . . . . . . . . . . .   8
     2.3.  Signature Expiration Time . . . . . . . . . . . . . . . .   8
     2.4.  Target Endpoint . . . . . . . . . . . . . . . . . . . . .   9
   3.  HTTP Message Signatures . . . . . . . . . . . . . . . . . . .  10
     3.1.  Signature Metadata  . . . . . . . . . . . . . . . . . . .  10
     3.2.  Creating a Signature  . . . . . . . . . . . . . . . . . .  10
       3.2.1.  Choose and Set Signature Metadata Properties  . . . .  11
       3.2.2.  Create the Signature Input  . . . . . . . . . . . . .  12
       3.2.3.  Sign the Signature Input  . . . . . . . . . . . . . .  13
     3.3.  Verifying a Signature . . . . . . . . . . . . . . . . . .  13
   4.  The 'Signature' HTTP Header . . . . . . . . . . . . . . . . .  14
     4.1.  Signature Header Parameters . . . . . . . . . . . . . . .  14
     4.2.  Examples  . . . . . . . . . . . . . . . . . . . . . . . .  16
       4.2.1.  RSA Example . . . . . . . . . . . . . . . . . . . . .  16
       4.2.2.  HMAC Example  . . . . . . . . . . . . . . . . . . . .  16
   5.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  17
     5.1.  HTTP Signature Algorithms Registry  . . . . . . . . . . .  17
       5.1.1.  Registration Template . . . . . . . . . . . . . . . .  17
       5.1.2.  Initial Contents  . . . . . . . . . . . . . . . . . .  18
   6.  Security Considerations . . . . . . . . . . . . . . . . . . .  20
   7.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  20
     7.1.  Normative References  . . . . . . . . . . . . . . . . . .  20
     7.2.  Informative References  . . . . . . . . . . . . . . . . .  21
   Appendix A.  Examples . . . . . . . . . . . . . . . . . . . . . .  22
     A.1.  Default Test  . . . . . . . . . . . . . . . . . . . . . .  23
     A.2.  Basic Test  . . . . . . . . . . . . . . . . . . . . . . .  23
     A.3.  All Headers Test  . . . . . . . . . . . . . . . . . . . .  24
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  24
   Document History  . . . . . . . . . . . . . . . . . . . . . . . .  24
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  27








Backman, et al.           Expires 10 June 2020                  [Page 2]

Internet-Draft            Signing HTTP Messages            December 2019


1.  Introduction

   Message integrity and authenticity are important security properties
   that are critical to the secure operation of many HTTP [RFC7230]
   applications.  Application developers typically rely on the transport
   layer to provide these properties, by operating their application
   over TLS [RFC8446].  However, TLS only guarantees these properties
   over a single TLS connection, and the path between client and
   application may be composed of multiple independent TLS connections
   (for example, if the application is hosted behind a TLS-terminating
   gateway or if the client is behind a TLS Inspection appliance).  In
   such cases, TLS cannot guarantee end-to-end message integrity or
   authenticity between the client and application.  Additionally, some
   operating environments present obstacles that make it impractical to
   use TLS, or to use features necessary to provide message
   authenticity.  Consequently, while TLS can meet message integrity and
   authenticity needs for many HTTP-based applications, it is not a
   universal solution.

   This document defines a mechanism for providing end-to-end integrity
   and authenticity for content within an HTTP message.  The mechanism
   allows applications to create digital signatures or message
   authentication codes (MACs) over only that content within the message
   that is meaningful and appropriate for the application.  Strict
   canonicalization rules ensure that the verifier can verify the
   signature even if the message has been transformed in any of the many
   ways permitted by HTTP.

   The mechanism described in this document consists of three parts:

   *  A common nomenclature and canonicalization rule set for the
      different protocol elements and other content within HTTP
      messages.

   *  Algorithms for generating and verifying signatures over HTTP
      message content using this nomenclature and rule set.

   *  A mechanism for attaching a signature and related metadata to an
      HTTP message.

1.1.  Requirements Discussion

   HTTP permits and sometimes requires intermediaries to transform
   messages in a variety of ways.  This may result in a recipient
   receiving a message that is not bitwise equivalent to the message
   that was oringally sent.  In such a case, the recipient will be
   unable to verify a signature over the raw bytes of the sender's HTTP
   message, as verifying digital signatures or MACs requires both signer



Backman, et al.           Expires 10 June 2020                  [Page 3]

Internet-Draft            Signing HTTP Messages            December 2019


   and verifier to have the exact same signed content.  Since the raw
   bytes of the message cannot be relied upon as signed content, the
   signer and verifier must derive the signed content from their
   respective versions of the message, via a mechanism that is resilient
   to safe changes that do not alter the meaning of the message.

   For a variety of reasons, it is impractical to strictly define what
   constitutes a safe change versus an unsafe one.  Applications use
   HTTP in a wide variety of ways, and may disagree on whether a
   particular piece of information in a message (e.g., the body, or the
   Date header field) is relevant.  Thus a general purpose solution must
   provide signers with some degree of control over which message
   content is signed.

   HTTP applications may be running in environments that do not provide
   complete access to or control over HTTP messages (such as a web
   browser's JavaScript environment), or may be using libraries that
   abstract away the details of the protocol (such as the Java
   HTTPClient library (https://openjdk.java.net/groups/net/httpclient/
   intro.html)).  These applications need to be able to generate and
   verify signatures despite incomplete knowledge of the HTTP message.

1.2.  HTTP Message Transformations

   As mentioned earlier, HTTP explicitly permits and in some cases
   requires implementations to transform messages in a variety of ways.
   Implementations are required to tolerate many of these
   transformations.  What follows is a non-normative and non-exhaustive
   list of transformations that may occur under HTTP, provided as
   context:

   *  Re-ordering of header fields with different header field names
      [RFC7230] (Section 3.2.2).

   *  Combination of header fields with the same field name [RFC7230]
      (Section 3.2.2).

   *  Removal of header fields listed in the "Connection" header field
      [RFC7230] (Section 6.1).

   *  Addition of header fields that indicate control options [RFC7230]
      (Section 6.1).

   *  Addition or removal of a transfer coding [RFC7230]
      (Section 5.7.2).

   *  Addition of header fields such as "Via" ([RFC7230], Section 5.7.1)
      and "Forwarded" ([RFC7239], Section 4).



Backman, et al.           Expires 10 June 2020                  [Page 4]

Internet-Draft            Signing HTTP Messages            December 2019


1.3.  Safe Transformations

   Based on the definition of HTTP and the requirements described above,
   we can identify certain types of transformations that should not
   prevent signature verification, even when performed on content
   covered by the signature.  The following list describes those
   transformations:

   *  Combination of header fields with the same field name.

   *  Reordering of header fields with different names.

   *  Conversion between HTTP/1.x and HTTP/2, or vice-versa.

   *  Changes in casing (e.g., "Origin" to "origin") of header field
      names, request URI scheme or host, or any other case-insensitive
      content.

   *  Addition or removal of leading or trailing whitespace to a header
      field value.

   *  Addition or removal of "obs-fold"s.

   *  Changes to the request-target and Host header field that when
      applied together do not result in a change to the message's
      effective request URI, as defined in Section 5.5 of [RFC7230].

   Additionally, all changes to content not covered by the signature are
   considered safe.

1.4.  Conventions and Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   The terms "HTTP message", "HTTP method", "HTTP request", "HTTP
   response", "absolute-form", "absolute-path", "effective request URI",
   "gateway", "header field", "intermediary", "request-target",
   "sender", and "recipient" are used as defined in HTTP [RFC7230].

   For brevity, the term "signature" on its own is used in this document
   to refer to both digital signatures and keyed MACs.  Similarly, the
   verb "sign" refers to the generation of either a digital signature or
   keyed MAC over a given input string.  The qualified term "digital




Backman, et al.           Expires 10 June 2020                  [Page 5]

Internet-Draft            Signing HTTP Messages            December 2019


   signature" refers specifically to the output of an asymmetric
   cryptographic signing operation.

   In addition to those listed above, this document uses the following
   terms:

   Decimal String
      An Integer String optionally concatenated with a period "".""
      followed by a second Integer String, representing a positive real
      number expressed in base 10.  The first Integer String represents
      the integral portion of the number, while the optional second
      Integer String represents the fractional portion of the number. //
      There's got to be a definition for this that we can reference.  Do
      // we have a max value or a limit on precision? // // -- AB

   Integer String
      A US-ASCII string of one or more digits ""0-9"", representing a
      positive integer in base 10.  // There's got to be a definition
      for this that we can reference.  Do // we have a max value? // //
      -- AB

   Signer
      The entity that is generating or has generated an HTTP Message
      Signature.

   Verifier
      An entity that is verifying or has verified an HTTP Message
      Signature against an HTTP Message.  Note that an HTTP Message
      Signature may be verified multiple times, potentially by different
      entities.

2.  Identifying and Canonicalizing Content

   In order to allow signers and verifiers to establish which content is
   covered by a signature, this document defines content identifiers for
   signature metadata and discrete pieces of message content that may be
   covered by an HTTP Message Signature.

   Some content within HTTP messages may undergo transformations that
   change the bitwise value without altering meaning of the content (for
   example, the merging together of header fields with the same name).
   Message content must therefore be canonicalized before it is signed,
   to ensure that a signature can be verified despite such innocuous
   transformations.  This document defines rules for each content
   identifier that transform the identifier's associated content into
   such a canonical form.





Backman, et al.           Expires 10 June 2020                  [Page 6]

Internet-Draft            Signing HTTP Messages            December 2019


   The following sections define content identifiers, their associated
   content, and their canonicalization rules.

   // This needs to be expanded to allow for more fine-grained inclusion
   // of message elements (e.g., method, scheme, authority, path, query
   // string parameters). // // -- AB

2.1.  HTTP Header Fields

   An HTTP header field value is identified by its header field name.
   While HTTP header field names are case-insensitive, implementations
   SHOULD use lowercased field names (e.g., "content-type", "date",
   "etag") when using them as content identifiers.

   An HTTP header field value is canonicalized as follows:

   1.  Create an ordered list of the field values of each instance of
       the header field in the message, in the order that they occur (or
       will occur) in the messge.

   2.  Strip leading and trailing whitespace from each item in the list.

   3.  Concatenate the list items together, with a comma "","" and space
       "" "" between each item.  The resulting string is the
       canonicalized value.

2.1.1.  Canonicalization Examples

   This section contains non-normative examples of canonicalized values
   for header fields, given the following example HTTP message:

   HTTP/1.1 200 OK
   Server: www.example.com
   Date: Tue, 07 Jun 2014 20:51:35 GMT
   X-OWS-Header:   Leading and trailing whitespace.
   X-Obs-Fold-Header: Obsolete
       line folding.
   X-Empty-Header:
   Cache-Control: max-age=60
   Cache-Control:    must-revalidate

   The following table shows example canonicalized values for header
   fields, given that message:

      +-----------------------+------------------------------------+
      | Header Field          | Canonicalized Value                |
      +=======================+====================================+
      | "(cache-control)"     | "max-age=60, must-revalidate"      |



Backman, et al.           Expires 10 June 2020                  [Page 7]

Internet-Draft            Signing HTTP Messages            December 2019


      +-----------------------+------------------------------------+
      | "(date)"              | "Tue, 07 Jun 2014 20:51:35 GMT"    |
      +-----------------------+------------------------------------+
      | "(server)"            | "www.example.com"                  |
      +-----------------------+------------------------------------+
      | "(x-empty-header)"    | ""                                 |
      +-----------------------+------------------------------------+
      | "(x-obs-fold-header)" | "Obsolete line folding."           |
      +-----------------------+------------------------------------+
      | "(x-ows-header)"      | "Leading and trailing whitespace." |
      +-----------------------+------------------------------------+

             Table 1: Non-normative examples of header field
                            canoncialization.

2.2.  Signature Creation Time

   The signature's Creation Time (Section 3.1) is identified by the
   "(created)" identifier.

   Its canoncalized value is an Integer String containing the
   signature's Creation Time expressed as the number of seconds since
   the Epoch, as defined in Section 4.16
   (https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/
   V1_chap04.html#tag_04_16) of [POSIX.1].

      |  The use of seconds since the Epoch to canonicalize a timestamp
      |  simplifies processing and avoids timezone management required
      |  by specifications such as [RFC3339].

2.3.  Signature Expiration Time

   The signature's Expiration Time (Section 3.1) is identified by the
   "(expired)" identifier.

   Its canonicalized value is a Decimal String containing the
   signature's Expiration Time expressed as the number of seconds since
   the Epoch, as defined in Section 4.16
   (https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/
   V1_chap04.html#tag_04_16) of [POSIX.1].

   // Needs more clarity on "decimal" format, cue arguments over //
   precision.  Do we need sub-second precision?  If we do, can we //
   make this an integer representing milliseconds since the Epoch? // Or
   replace with a maximum age expressed in milliseconds? // // -- AB






Backman, et al.           Expires 10 June 2020                  [Page 8]

Internet-Draft            Signing HTTP Messages            December 2019


2.4.  Target Endpoint

   The request target endpoint, consisting of the HTTP method and the
   path and query of the effective request URI, is identified by the
   "(request-target)" identifier.

   Its value is canonicalized as follows:

   1.  Take the lowercased HTTP method of the message.

   2.  Append a space "" "".

   3.  Append the path and query of the request target of the message,
       formatted according to the rules defined for the ":path" pseudo-
       header in HTTP/2 [RFC7540], Section 8.1.2.3.  The resulting
       string is the canonicalized value.

2.4.1.  Canonicalization Examples

   The following table contains non-normative example HTTP messages and
   their canonicalized "(request-target)" values.

   +-------------------------------------------+----------------------+
   | HTTP Message                              | "(request-target)"   |
   +===========================================+======================+
   |    POST /?param=value HTTP/1.1            | "post /?param=value" |
   |    Host: www.example.com                  |                      |
   +-------------------------------------------+----------------------+
   |    POST /a/b HTTP/1.1                     | "post /a/b"          |
   |    Host: www.example.com                  |                      |
   +-------------------------------------------+----------------------+
   |    GET http://www.example.com/a/ HTTP/1.1 | "get /a/"            |
   +-------------------------------------------+----------------------+
   |    GET http://www.example.com HTTP/1.1    | "get /"              |
   +-------------------------------------------+----------------------+
   |    CONNECT server.example.com:80 HTTP/1.1 | "connect /"          |
   |    Host: server.example.com               |                      |
   +-------------------------------------------+----------------------+
   |    OPTIONS * HTTP/1.1                     | "options *"          |
   |    Host: server.example.com               |                      |
   +-------------------------------------------+----------------------+

          Table 2: Non-normative examples of "(request-target)"
                            canonicalization.







Backman, et al.           Expires 10 June 2020                  [Page 9]

Internet-Draft            Signing HTTP Messages            December 2019


3.  HTTP Message Signatures

   An HTTP Message Signature is a signature over a string generated from
   a subset of the content in an HTTP message and metadata about the
   signature itself.  When successfully verified against an HTTP
   message, it provides cryptographic proof that with respect to the
   subset of content that was signed, the message is semantically
   equivalent to the message for which the signature was generated.

3.1.  Signature Metadata

   HTTP Message Signatures have metadata properties that provide
   information regarding the signature's generation and/or verification.
   The following metadata properties are defined:

   Algorithm
      An HTTP Signature Algorithm defined in the IANA HTTP Signature
      Algorithms registry (Section 5.1) defined in this document.  It
      describes the signing and verification algorithms for the
      signature.

   Creation Time
      A timestamp representing the point in time that the signature was
      generated.  Sub-second precision is not supported.  A signature's
      Creation Time MAY be undefined, indicating that it is unknown.

   Covered Content
      An ordered list of content identifiers (Section 2) that indicates
      the metadata and message content that is covered by the signature.
      The order of identifiers in this list affects signature generation
      and verification, and therefore MUST be preserved.

   Expiration Time
      A timestamp representing the point in time at which the signature
      expires.  An expired signature always fails verification.  A
      signature's Expiration Time MAY be undefined, indicating that the
      signature does not expire.

   Verification Key Material
      The key material required to verify the signature.

3.2.  Creating a Signature

   In order to create a signature, a signer completes the following
   process:

   1.  Choose key material and algorithm, and set metadata properties
       (Section 3.2.1)



Backman, et al.           Expires 10 June 2020                 [Page 10]

Internet-Draft            Signing HTTP Messages            December 2019


   2.  Create the Signature Input (Section 3.2.2)

   3.  Sign the Signature Input (Section 3.2.3)

   The following sections describe each of these steps in detail.

3.2.1.  Choose and Set Signature Metadata Properties

   1.  The signer chooses an HTTP Signature Algorithm from those
       registered in the IANA HTTP Signature Algorithm Registry
       (Section 5.1) defined by this document, and sets the signature's
       Algorithm property to that value.  The signer MUST NOT choose an
       algorithm marked "Deprecated".  The mechanism by which the signer
       chooses an algorithm is out of scope for this document.

   2.  The signer chooses key material to use for signing and
       verification, and sets the signature's Verification Key Material
       property to the key material required for verification.  The
       signer MUST choose key material that is appropriate for the
       signature's Algorithm, and that conforms to any requirements
       defined by the Algorithm, such as key size or format.  The
       mechanism by which the signer chooses key material is out of
       scope for this document.

   3.  The signer sets the signature's Creation Time property to the
       current time.

   4.  The signer sets the signature's Expiration Time property to the
       time at which the signature is to expire, or to undefined if the
       signature will not expire.

   5.  The signer creates an ordered list of content identifiers
       representing the message content and signature metadata to be
       covered by the signature, and assigns this list as the
       signature's Covered Content.  Each identifier MUST be one of
       those defined in Section 2.  This list MUST NOT be empty, as this
       would result in creating a signature over the empty string.  If
       the signature's Algorithm name does not start with "rsa", "hmac",
       or "ecdsa", signers SHOULD include "(created)" and "(request-
       target)" in the list.  If the signature's Algorithm starts with
       "rsa", "hmac", or "ecdsa", signers SHOULD include "date" and
       "(request-target)" in the list.  Further guidance on what to
       include in this list and in what order is out of scope for this
       document.  However, the list order is significant and once
       established for a given signature it MUST be preserved for that
       signature.





Backman, et al.           Expires 10 June 2020                 [Page 11]

Internet-Draft            Signing HTTP Messages            December 2019


3.2.2.  Create the Signature Input

   The Signature Input is a US-ASCII string containing the content that
   will be signed.  To create it, the signer concatenates together
   entries for each identifier in the signature's Covered Content in the
   order it occurs in the list, with each entry separated by a newline
   ""\n"".  An identifier's entry is a US-ASCII string consisting of the
   lowercased identifier followed with a colon "":"", a space "" "", and
   the identifier's canonicalized value (described below).

   If Covered Content contains "(created)" and the signature's Creation
   Time is undefined or the signature's Algorithm name starts with
   "rsa", "hmac", or "ecdsa" an implementation MUST produce an error.

   If Covered Content contains "(expires)" and the signature does not
   have an Expiration Time or the signature's Algorithm name starts with
   "rsa", "hmac", or "ecdsa" an implementation MUST produce an error.

   If Covered Content contains an identifier for a header field that is
   not present or malformed in the message, the implementation MUST
   produce an error.

   To illustrate the rules specified above, assume the signature's
   Covered Content is a list containing "(request-target)", "(created)",
   "host", "date", "cache-control", "x-emptyheader", and "x-example", in
   order, the signature's Creation Time is equal to the value of the
   message's Date header, and the following HTTP message:

   GET /foo HTTP/1.1
   Host: example.org
   Date: Tue, 07 Jun 2014 20:51:35 GMT
   X-Example: Example header
           with some whitespace.
   X-EmptyHeader:
   Cache-Control: max-age=60
   Cache-Control: must-revalidate

   For the HTTP message above, the corresponding Signature Input is:

   (request-target): get /foo
   (created): 1402170695
   host: example.org
   date: Tue, 07 Jun 2014 20:51:35 GMT
   cache-control: max-age=60, must-revalidate
   x-emptyheader:
   x-example: Example header with some whitespace.





Backman, et al.           Expires 10 June 2020                 [Page 12]

Internet-Draft            Signing HTTP Messages            December 2019


3.2.3.  Sign the Signature Input

   The signer signs the Signature Input using the signing algorithm
   described by the signature's Algorithm property, and the key material
   chosen by the signer.  The signer then encodes the result of that
   operation as a base 64-encoded string [RFC4648].  This string is the
   signature value.

   For example, assume that the Algorithm is "hs2019" and the key is an
   EdDSA private key.  This would signal to the application that the the
   signing algorithm is Ed25519 as defined in RFC 8032 [RFC8032],
   Section 5.1.  The result of the signing algorithm should be a binary
   string, which once base 64 encoded becomes the signature value.

3.3.  Verifying a Signature

   In order to verify a signature, a verifier MUST:

   1.  Use the received HTTP message and the signature's metadata to
       recreate the Signature Input, using the process described in
       Section 3.2.2.

   2.  Use the signature's Algorithm and Verification Key Material with
       the recreated Signing Input to verify the signature value.

   A signature with a Creation Time that is in the future or an
   Expiration Time that is in the past MUST NOT be processed. // This
   wording implies that verifiers are not permitted to account // for
   clock skew during signature verification. // // -- AB

   The verifier MUST ensure that a signature's Algorithm is appropriate
   for the key material the verifier will use to verify the signature.
   If the Algorithm is not appropriate for the key material (for
   example, if it is the wrong size, or in the wrong format), the
   signature MUST NOT be processed.

   For example, assume that the Algorithm was "hs2019" and the
   Verification Key Material is an EdDSA public key.  This would signal
   to the application that the signing algorithm is Ed25519 as defined
   in RFC 8032 [RFC8032], Section 5.1.  The result of the signature
   verification algorithm should result in a successful verification
   unless the message content or signature metadata protected by the
   signature were tampered with in transit.








Backman, et al.           Expires 10 June 2020                 [Page 13]

Internet-Draft            Signing HTTP Messages            December 2019


4.  The 'Signature' HTTP Header

   The "Signature" HTTP header provides a mechanism to attach a
   signature to the HTTP message from which it was generated.  The
   header field name is "Signature" and its value is a list of
   parameters and values, formatted according to the "signature" syntax
   defined below, using the extended Augmented Backus-Naur Form (ABNF)
   notation used in [RFC7230].

   signature    = #( sig-param )

   sig-param    = token BWS "=" BWS ( token / quoted-string )

   Each "sig-param" is a parameter defined in Section 4.1.

4.1.  Signature Header Parameters

   The Signature header's parameters contain the signature value itself
   and the signature metadata properties required to verify the
   signature.  Unless otherwise specified, parameters MUST NOT occur
   multiple times in one header, whether with the same or different
   values.  The following parameters are defined:

   "algorithm"
      RECOMMENDED.  The "algorithm" parameter contains the name of the
      signature's Algorithm, as registered in the IANA HTTP Signature
      Algorithms Registry (Section 5.1) defined by this document.
      Verifiers MUST determine the signature's Algorithm from the
      "keyId" parameter rather than from "algorithm".  If "algorithm" is
      provided and differs from or is incompatible with the algorithm or
      key material identified by "keyId" (for example, "algorithm" has a
      value of "rsa-sha256" but "keyId" identifies an EdDSA key), then
      implementations MUST produce an error.  Implementers should note
      that previous versions of this specification determined the
      signature's Algorithm using the "algorithm" parameter only, and
      thus could be utilized by attackers to expose security
      vulnerabilities.

      // These instructions are confusing.  Punting algorithm //
      identification into "keyId" hurts interoperability, since we //
      aren't defining the syntax or semantics of "keyId".  It also goes
      // against the statement that we _aren't_ defining "keyId"'s //
      semantics, as we are dictating that the signing algorithm must be
      // specified by "keyId" or derivable from it.  If we stick with
      this, // can we just drop "algorithm" altogether? // // -- AB

   "created"
      RECOMMENDED.  The "created" parameter contains the signature's



Backman, et al.           Expires 10 June 2020                 [Page 14]

Internet-Draft            Signing HTTP Messages            December 2019


      Creation Time, expressed as the canonicalized value of the
      "(created)" content identifier, as defined in Section 2.  If not
      specified, the signature's Creation Time is undefined.  This
      parameter is useful when signers are not capable of controlling
      the "Date" HTTP Header such as when operating in certain web
      browser environments.

   "expires"
      OPTIONAL.  The "expires" parameter contains the signature's
      Expiration Time, expressed as the canonicalized value of the
      "(expires)" content identifier, as defined in Section 2.  If the
      signature does not have an Expiration Time, this parameter "MUST"
      be omitted.

   "headers"
      OPTIONAL.  The "headers" parameter contains the signature's
      Covered Content, expressed as a string containing a quoted list of
      the identifiers in the list, in the order they occur in the list,
      with a space "" "" between each identifier.  If specified,
      identifiers for header fields SHOULD be lowercased and all others
      MUST be lowercased.  If not specified, verifiers MUST assume the
      signature's Covered Content is a list containing only a single
      "(created)" identifier.

      // The name "headers" is misleading, as this parameter will
      contain // entries that are not HTTP header field names (e.g.,
      "(created)"). // // -- AB

   "keyId"
      REQUIRED.  The "keyId" parameter is a US-ASCII string whose value
      can be used by a verifier to identify and/or obtain the
      signature's "Verification Key Material".  The format and semantics
      of this value are out of scope for this document.

      // This value needs to be constrained to ensure that it does not
      // break parsing of the header field's value as auth-params. // //
      -- AB

      // While we need to allow for flexibility in key specification, //
      leaving it completely undefined hurts interoperability.  We could
      // borrow from JOSE and define "jwk" and "jku" parameters as //
      extensible ways to specify common types of keys. // // -- AB

   "signature"
      REQUIRED.  The "signature" parameter contains the signature value,
      as described in Section 3.2.3.





Backman, et al.           Expires 10 June 2020                 [Page 15]

Internet-Draft            Signing HTTP Messages            December 2019


4.2.  Examples

   The following non-normative examples are based on the following HTTP
   message:

   POST /foo HTTP/1.1
   Host: example.com
   Date: Tue, 07 Jun 2014 20:51:35 GMT
   Content-Type: application/json
   Digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
   Content-Length: 18

   {"hello": "world"}

   The following examples assume that the "rsa-key-1" keyId provided by
   the signer is meaningful to the verifier.  Note that to improve
   readability, some header values are split into multiple lines, using
   the "obs-fold" syntax.  This syntax is deprecated in [RFC7230], and
   senders MUST NOT generate messages that include it.

4.2.1.  RSA Example

   The signature header and signature would be generated as:

   Signature: keyId="rsa-key-1",algorithm="hs2019",
       created=1402170695, expires=1402170995,
       headers="(request-target) (created) (expires)
           host date digest content-length",
       signature="Base64(RSA-SHA256(signing string))"

   To verify the signature, a verifier would compose the Signature Input
   as:

   (request-target): post /foo
   (created): 1402170695
   (expires): 1402170995
   host: example.org
   digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
   content-length: 18

4.2.2.  HMAC Example

   For an HMAC-based signature without a list of headers specified, the
   authorization header and signature would be generated as:

   Signature: keyId="hmac-key-1",algorithm="hs2019",created=1402170695,
       headers="(request-target) (created) host digest content-length",
       signature="Base64(HMAC-SHA512(signing string))"



Backman, et al.           Expires 10 June 2020                 [Page 16]

Internet-Draft            Signing HTTP Messages            December 2019


   The only difference between the RSA Example and the HMAC Example is
   the signature algorithm that is used.  The verifier would compose the
   Signature Input in the same way as the RSA Example above:

   (request-target): post /foo\n
   (created): 1402170695
   host: example.org\n
   digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=\n
   content-length: 18

5.  IANA Considerations

5.1.  HTTP Signature Algorithms Registry

   // JSON Web Algorithms (JWA) [RFC7518] already defines an IANA //
   registry for cryptographic algorithms.  What is the justification //
   for defining a new one? // // -- AB

   This document defines HTTP Signature Algorithms, for which IANA is
   asked to create and maintain a new registry titled "HTTP Signature
   Algorithms".  Initial values for this registry are given in
   Section 5.1.2.  Future assignments and modifications to existing
   assignment are to be made through the Expert Review registration
   policy [BCP 26] and shall follow the template presented in
   Section 5.1.1.

5.1.1.  Registration Template

   Algorithm Name
      An identifier for the HTTP Signature Algorithm.  The name MUST be
      an ASCII string consisting only of lower-case characters (""a"" -
      ""z""), digits (""0"" - ""9""), and hyphens (""-""), and SHOULD
      NOT exceed 20 characters in length.  The identifier MUST be unique
      within the context of the registry.

   Status
      A brief text description of the status of the algorithm.  The
      description MUST begin with one of "Active" or "Deprecated", and
      MAY provide further context or explanation as to the reason for
      the status.

   Description
      A description of the algorithm used to sign the signing string
      when generating an HTTP Message Signature, or instructions on how
      to determine that algorithm.  When the description specifies an
      algorithm, it MUST include a reference to the document or
      documents that define the algorithm.




Backman, et al.           Expires 10 June 2020                 [Page 17]

Internet-Draft            Signing HTTP Messages            December 2019


5.1.2.  Initial Contents

   // The references in this section are problematic as many of the //
   specifications that they refer to are too implementation specific, //
   rather than just pointing to the proper signature and hashing //
   specifications.  A better approach might be just specifying the //
   signature and hashing function specifications, leaving //
   implementers to connect the dots (which are not that hard to //
   connect). // // -- MS

   // Initial registry contents should not contain deprecated //
   algorithms. // // -- AB

"hs2019"

   Algorithm Name
      "hs2019"

   Status
      active

   Description
      Derived from metadata associated with "keyId".  Recommend support
      for:

      *  RSASSA-PSS [RFC8017] using SHA-512 [RFC6234]

      *  HMAC [RFC2104] using SHA-512 [RFC6234]

      *  ECDSA using curve P-256 [DSS] and SHA-512 [RFC6234]

      *  Ed25519ph, Ed25519ctx, and Ed25519 [RFC8032]

      // Pushing this into "keyId" without guidance on "keyId"'s format
      // hurts interoperability and contradicts the earlier statement
      that // the structure and semantics of "keyId" are out of scope.
      These // should each be defined as separate algorithms, and the //
      verification steps should require the verifier to confirm that the
      // specified key fits the specified algorithm. // // -- AB

"rsa-sha1"

   Algorithm Name
      "rsa-sha1"

   Status
      Deprecated; SHA-1 not secure.




Backman, et al.           Expires 10 June 2020                 [Page 18]

Internet-Draft            Signing HTTP Messages            December 2019


      // What does "not secure" mean in this context?  Should this even
      be // defined if there are security concerns? // // -- AB

   Description
      RSASSA-PKCS1-v1_5 [RFC8017] using SHA-1 [RFC6234]

"rsa-sha256"

   Algorithm Name
      "rsa-sha256"

   Status
      Deprecated; specifying signature algorithm enables attack vector.

      // What attack vector?  Can we mitigate it by including
      "algorithm" // in the signing string? // // -- AB

   Description
      RSASSA-PKCS1-v1_5 [RFC8017] using SHA-256 [RFC6234]

"hmac-sha256"

   Algorithm Name
      "hmac-sha256"

   Status
      Deprecated; specifying signature algorithm enables attack vector.

      // What attack vector?  Can we mitigate it by including
      "algorithm" // in the signing string? // // -- AB

   Description
      HMAC [RFC2104] using SHA-256 [RFC6234]

"ecdsa-sha256"

   Algorithm Name
      "ecdsa-sha256"

   Status
      Deprecated; specifying signature algorithm enables attack vector.

      // What attack vector?  Can we mitigate it by including
      "algorithm" // in the signing string? // // -- AB

   Description
      ECDSA using curve P-256 [DSS] and SHA-256 [RFC6234]




Backman, et al.           Expires 10 June 2020                 [Page 19]

Internet-Draft            Signing HTTP Messages            December 2019


6.  Security Considerations

   // TODO: need to dive deeper on this section; not sure how much of //
   what's referenced below is actually applicable, or if it covers //
   everything we need to worry about. // // -- AB

   There are a number of security considerations to take into account
   when implementing or utilizing this specification.  A thorough
   security analysis of this protocol, including its strengths and
   weaknesses, can be found in Security Considerations for HTTP
   Signatures [WP-HTTP-Sig-Audit].

7.  References

7.1.  Normative References

   [BCP 26]   Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/info/rfc8126>.

   [DSS]      NIST, "Digital Signature Standard (DSS)", FIPS 186-4,
              DOI 10.6028/NIST.FIPS.186-4, July 2013,
              <https://csrc.nist.gov/publications/detail/fips/186/4/
              final>.

   [POSIX.1]  IEEE and The Open Group, "The Open Group Base
              Specifications Issue 7, 2018 edition", IEEE
              Std 1003.1-2017, 2018,
              <https://pubs.opengroup.org/onlinepubs/9699919799/>.

   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", RFC 2104,
              DOI 10.17487/RFC2104, February 1997,
              <https://www.rfc-editor.org/info/rfc2104>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC4648]  Josefsson, S., "The Base16, Base32, and Base64 Data
              Encodings", RFC 4648, DOI 10.17487/RFC4648, October 2006,
              <https://www.rfc-editor.org/info/rfc4648>.

   [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing",




Backman, et al.           Expires 10 June 2020                 [Page 20]

Internet-Draft            Signing HTTP Messages            December 2019


              RFC 7230, DOI 10.17487/RFC7230, June 2014,
              <https://www.rfc-editor.org/info/rfc7230>.

   [RFC7540]  Belshe, M., Peon, R., and M. Thomson, Ed., "Hypertext
              Transfer Protocol Version 2 (HTTP/2)", RFC 7540,
              DOI 10.17487/RFC7540, May 2015,
              <https://www.rfc-editor.org/info/rfc7540>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

7.2.  Informative References

   [RFC3339]  Klyne, G. and C. Newman, "Date and Time on the Internet:
              Timestamps", RFC 3339, DOI 10.17487/RFC3339, July 2002,
              <https://www.rfc-editor.org/info/rfc3339>.

   [RFC6234]  Eastlake 3rd, D. and T. Hansen, "US Secure Hash Algorithms
              (SHA and SHA-based HMAC and HKDF)", RFC 6234,
              DOI 10.17487/RFC6234, May 2011,
              <https://www.rfc-editor.org/info/rfc6234>.

   [RFC7239]  Petersson, A. and M. Nilsson, "Forwarded HTTP Extension",
              RFC 7239, DOI 10.17487/RFC7239, June 2014,
              <https://www.rfc-editor.org/info/rfc7239>.

   [RFC7518]  Jones, M., "JSON Web Algorithms (JWA)", RFC 7518,
              DOI 10.17487/RFC7518, May 2015,
              <https://www.rfc-editor.org/info/rfc7518>.

   [RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,
              "PKCS #1: RSA Cryptography Specifications Version 2.2",
              RFC 8017, DOI 10.17487/RFC8017, November 2016,
              <https://www.rfc-editor.org/info/rfc8017>.

   [RFC8032]  Josefsson, S. and I. Liusvaara, "Edwards-Curve Digital
              Signature Algorithm (EdDSA)", RFC 8032,
              DOI 10.17487/RFC8032, January 2017,
              <https://www.rfc-editor.org/info/rfc8032>.

   [RFC8446]  Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/info/rfc8446>.

   [WP-HTTP-Sig-Audit]
              Sporny, M., "Security Considerations for HTTP Signatures",




Backman, et al.           Expires 10 June 2020                 [Page 21]

Internet-Draft            Signing HTTP Messages            December 2019


              June 2013, <https://web-payments.org/specs/source/http-
              signatures-audit/>.

Appendix A.  Examples

   The examples in this section use the following RSA 2048-bit keys,
   which we will refer to as "keyId=Test":

   -----BEGIN RSA PUBLIC KEY-----
   MIIBCgKCAQEAhAKYdtoeoy8zcAcR874L8cnZxKzAGwd7v36APp7Pv6Q2jdsPBRrw
   WEBnez6d0UDKDwGbc6nxfEXAy5mbhgajzrw3MOEt8uA5txSKobBpKDeBLOsdJKFq
   MGmXCQvEG7YemcxDTRPxAleIAgYYRjTSd/QBwVW9OwNFhekro3RtlinV0a75jfZg
   kne/YiktSvLG34lw2zqXBDTC5NHROUqGTlML4PlNZS5Ri2U4aCNx2rUPRcKIlE0P
   uKxI4T+HIaFpv8+rdV6eUgOrB2xeI1dSFFn/nnv5OoZJEIB+VmuKn3DCUcCZSFlQ
   PSXSfBDiUGhwOw76WuSSsf1D4b/vLoJ10wIDAQAB
   -----END RSA PUBLIC KEY-----

   -----BEGIN RSA PRIVATE KEY-----
   MIIEqAIBAAKCAQEAhAKYdtoeoy8zcAcR874L8cnZxKzAGwd7v36APp7Pv6Q2jdsP
   BRrwWEBnez6d0UDKDwGbc6nxfEXAy5mbhgajzrw3MOEt8uA5txSKobBpKDeBLOsd
   JKFqMGmXCQvEG7YemcxDTRPxAleIAgYYRjTSd/QBwVW9OwNFhekro3RtlinV0a75
   jfZgkne/YiktSvLG34lw2zqXBDTC5NHROUqGTlML4PlNZS5Ri2U4aCNx2rUPRcKI
   lE0PuKxI4T+HIaFpv8+rdV6eUgOrB2xeI1dSFFn/nnv5OoZJEIB+VmuKn3DCUcCZ
   SFlQPSXSfBDiUGhwOw76WuSSsf1D4b/vLoJ10wIDAQABAoIBAG/JZuSWdoVHbi56
   vjgCgkjg3lkO1KrO3nrdm6nrgA9P9qaPjxuKoWaKO1cBQlE1pSWp/cKncYgD5WxE
   CpAnRUXG2pG4zdkzCYzAh1i+c34L6oZoHsirK6oNcEnHveydfzJL5934egm6p8DW
   +m1RQ70yUt4uRc0YSor+q1LGJvGQHReF0WmJBZHrhz5e63Pq7lE0gIwuBqL8SMaA
   yRXtK+JGxZpImTq+NHvEWWCu09SCq0r838ceQI55SvzmTkwqtC+8AT2zFviMZkKR
   Qo6SPsrqItxZWRty2izawTF0Bf5S2VAx7O+6t3wBsQ1sLptoSgX3QblELY5asI0J
   YFz7LJECgYkAsqeUJmqXE3LP8tYoIjMIAKiTm9o6psPlc8CrLI9CH0UbuaA2JCOM
   cCNq8SyYbTqgnWlB9ZfcAm/cFpA8tYci9m5vYK8HNxQr+8FS3Qo8N9RJ8d0U5Csw
   DzMYfRghAfUGwmlWj5hp1pQzAuhwbOXFtxKHVsMPhz1IBtF9Y8jvgqgYHLbmyiu1
   mwJ5AL0pYF0G7x81prlARURwHo0Yf52kEw1dxpx+JXER7hQRWQki5/NsUEtv+8RT
   qn2m6qte5DXLyn83b1qRscSdnCCwKtKWUug5q2ZbwVOCJCtmRwmnP131lWRYfj67
   B/xJ1ZA6X3GEf4sNReNAtaucPEelgR2nsN0gKQKBiGoqHWbK1qYvBxX2X3kbPDkv
   9C+celgZd2PW7aGYLCHq7nPbmfDV0yHcWjOhXZ8jRMjmANVR/eLQ2EfsRLdW69bn
   f3ZD7JS1fwGnO3exGmHO3HZG+6AvberKYVYNHahNFEw5TsAcQWDLRpkGybBcxqZo
   81YCqlqidwfeO5YtlO7etx1xLyqa2NsCeG9A86UjG+aeNnXEIDk1PDK+EuiThIUa
   /2IxKzJKWl1BKr2d4xAfR0ZnEYuRrbeDQYgTImOlfW6/GuYIxKYgEKCFHFqJATAG
   IxHrq1PDOiSwXd2GmVVYyEmhZnbcp8CxaEMQoevxAta0ssMK3w6UsDtvUvYvF22m
   qQKBiD5GwESzsFPy3Ga0MvZpn3D6EJQLgsnrtUPZx+z2Ep2x0xc5orneB5fGyF1P
   WtP+fG5Q6Dpdz3LRfm+KwBCWFKQjg7uTxcjerhBWEYPmEMKYwTJF5PBG9/ddvHLQ
   EQeNC8fHGg4UXU8mhHnSBt3EA10qQJfRDs15M38eG2cYwB1PZpDHScDnDA0=
   -----END RSA PRIVATE KEY-----

   All examples use this HTTP message:





Backman, et al.           Expires 10 June 2020                 [Page 22]

Internet-Draft            Signing HTTP Messages            December 2019


   POST /foo?param=value&pet=dog HTTP/1.1
   Host: example.com
   Date: Sun, 05 Jan 2014 21:31:40 GMT
   Content-Type: application/json
   Digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
   Content-Length: 18

   {"hello": "world"}

A.1.  Default Test

   // This statement about default Covered Content is inaccurate. // //
   -- AB"rsa-sha256".  The string to sign would be:

   date: Sun, 05 Jan 2014 21:31:40 GMT

   The Signature header would be:

   Signature: keyId="Test",algorithm="rsa-sha256",
       signature="R1ngRJLqHG6A7w0XR2JFCgLrQbIK7gVp/IkzS1zYbDA4mJbkR06Od
       GCS/rLNNcqNOW02Ca2fjeKz9qGfVYzqBUeJJJhvqitB7d0GHxNf1ZvlfWoQlWx0Q
       o3c1e7jhn7hlGe28d3qdfmMO4lxcv8acbB5Xo9MDu/gLgLuPPG2iCViS9SnZjwgQ
       ZdeWc6H7hSw8y8myA8yvc9P7LtEBJzHLxvFCW739nxTLNDxuIHcECtreP9Z+gAcW
       ZnJ59yXmF6kjTQnWUmCSzP1zqraF0eODgfXvejjzILxjZ1nI3RrioOwRtbT2DH5j
       BLi6MlAQh/dkG14/ucZyb0yrEBrqRd6ig=="

A.2.  Basic Test

   // This statement about minimum recommended Covered Content is //
   inaccurate. // // -- AB"(request-target)", "host", and "date".  In
   this case, the string to sign would be:

   (request-target): post /foo?param=value&pet=dog
   host: example.com
   date: Sun, 05 Jan 2014 21:31:40 GMT

   The Signature header would be:

   Signature: keyId="Test",algorithm="rsa-sha256",
       headers="(request-target) host date",
       signature="TSkjEULCH2HKgS23CF9E6pFfoFnCOOmPqYqlytuTgh/4agD2x2pbJ
       SaAiOaj1ct0zxY1nmBWEs3RNzEURNFPHcwTyK2e9HqpMeHtzz9U8us9UWmE/SJiE
       fsp4C3dORtjuN1cGHQ9mEfiDStb/ucSGrBIrmSP4hIFGlJjzOIiFFDqxppHmpWag
       9zELYUMq0nXryKYProoyssryOvzuwTM0mNWU/KEsxCpYqDsFXxY9A/ayHSrQlqMh
       xhGLtcSz2kLSoKj0+hM/gJLC6UFC1Okd1ljhsWIax/N3octJC5A53saETcsLtzrz
       ecei1JNdJctO7VVRIbglHNuNqRs7XwOBg=="





Backman, et al.           Expires 10 June 2020                 [Page 23]

Internet-Draft            Signing HTTP Messages            December 2019


A.3.  All Headers Test

   A strong signature including all of the headers and a digest of the
   body of the HTTP request would result in the following signing
   string:

   (request-target): post /foo?param=value&pet=dog
   host: example.com
   date: Sun, 05 Jan 2014 21:31:40 GMT
   content-type: application/json
   digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
   content-length: 18

   The Signature header would be:

   Signature: keyId="Test",algorithm="rsa-sha256",
       created=1402170695, expires=1402170699,
       headers="(request-target) (created) (expires)
       host date content-type digest content-length",
       signature="DCx3tr/0pZU+ecTOrnXzWMtv/OYDl5PMJUIdd4ApuZCk8vb0QlFga
       FFPreMUG33g7IO/4zH56Ld67vTLyjIQcDxYK/ad42EqkSrzainPYt0lpOPLUwxj6
       ZCM9NWAqrBvkQGRo4y+OcAFPfGDSNJw95CwHICL50rm7VCLP5rVhSt7TM1Qd2STY
       HoNb2BnwVEAkWemI68aZQaUD3uwH01I71EPrMAo8YHULeKPyOwpJowMBCDWl9061
       2qy7UCUlz86bBRqqVIyPI9/5NV50UGP1QBtD61iXKUh0n3KcAHbODyO8+AVtnWAB
       rlhceJEwvmhBak8LAdGTlY4EGOrHeeLLQ=="

Acknowledgements

   This specification is based on the draft-cavage-http-signatures
   draft.  The editor would like to thank the authors of that draft,
   Mark Cavage and Manu Sporny, for their work on that draft and their
   continuing contributions.

   The editor would also like to thank the following individuals for
   feedback on and implementations of the draft-cavage-http-signatures
   draft (in alphabetical order): Mark Adamcin, Mark Allen, Paul
   Annesley, Karl Boehlmark, Stephane Bortzmeyer, Sarven Capadisli, Liam
   Dennehy, ductm54, Stephen Farrell, Phillip Hallam-Baker, Eric Holmes,
   Andrey Kislyuk, Adam Knight, Dave Lehn, Dave Longley, James H.
   Manger, Ilari Liusvaara, Mark Nottingham, Yoav Nir, Adrian Palmer,
   Lucas Pardue, Roberto Polli, Julian Reschke, Michael Richardson,
   Wojciech Rygielski, Adam Scarr, Cory J.  Slep, Dirk Stein, Henry
   Story, Lukasz Szewc, Chris Webber, and Jeffrey Yasskin

Document History

   This section is to be removed before publishing as an RFC.




Backman, et al.           Expires 10 June 2020                 [Page 24]

Internet-Draft            Signing HTTP Messages            December 2019


   *  *draft-richanna-http-message-signatures*

      -  *-00*

         o  Converted to xml2rfc v3 and reformatted to comply with RFC
            style guides.

         o  Rewrote abstract and introduction to focus on general
            purpose signing and avoid specific use cases.

         o  Added intro sections on challenges with HTTP message
            signing, and listing innocuous transformations that the
            signing mechanism must tolerate.

         o  Added Document History section.

         o  Removed informative intro sections on Signatures in HTTP
            Requests/Responses, as they imply specific use cases.

         o  Moved BCP 14 message under intro section.

         o  Removed "Signature" auth-scheme definition and non-normative
            description of using the "Signature" header field for
            authentication.

         o  Removed "Canonicalization Algorithm" from HTTP Signature
            Algorithms registry entries.

         o  Replaced mentions of ANSI X9.64 with normative references to
            FIPS 186-4.

         o  Combined HTTP Signature Algorithms registry entry algorithm
            fields into a "Description" field.

         o  Revised HTTP Signature Algorithms registry definition.
            Added change control policy and registry template.  Removed
            suggested URI.

         o  Moved normative text related to ambiguous signature
            parameters to Signature header definition.

         o  Added normative reference to RFC 2104 for HMAC.

         o  Added informative reference to RFC 3339.

         o  Added normative reference to POSIX.1 in `created` and
            `expires` parameter definitions.




Backman, et al.           Expires 10 June 2020                 [Page 25]

Internet-Draft            Signing HTTP Messages            December 2019


         o  Added definitions for HTTP-related terms by referencing RFC
            7230.

         o  Added definitions for Signer and Verifier, and placeholder
            entries for Signing Algorithm and Signing String.

         o  Added definition of signature as applying to both digital
            signatures and MACs.

         o  Renamed The Components of a Signature to HTTP Message
            Signatures.  Revised to define message signatures without
            reference to Authorization or Signature headers.

         o  Added Signature Metadata section.  Moved normative
            requirements in Signature Parameters out to appropriate
            places (e.g., signature creation), redefined parameters in
            terms of metadata properties, and moved them to Signature
            header section.

         o  Dropped definitions for unused terms Signing Algorithm and
            Signing String

         o  Moved metadata expressions to canonicalization section.

         o  Added detailed description of signature generation and
            verification process.

         o  Removed duplication of normative requirements, consolidated
            requirements for generation and verification to their
            respective sections.

         o  Replaced Key Reference metadata property with Verification
            Key Material.

         o  Removed conflicting normative requirements for use of
            "algorithm" parameter.  Now MUST NOT be relied upon.

         o  Moved Content Identifiers up to its own top-level section.

         o  Explicitly defined Integer String and Decimal String.

         o  Consolidated content identifiers and canonicalization rules
            into a single section.

         o  Added examples for header field and "(request-target)"
            canonicalization.





Backman, et al.           Expires 10 June 2020                 [Page 26]

Internet-Draft            Signing HTTP Messages            December 2019


         o  Removed Extensions appendix and fixed keys and signatures on
            test examples.

         o  Revised introduction around need for non-TLS integrity/
            authenticity protection.  Added Requirements Description.

         o  Revised Signature header definition.

Authors' Addresses

   Annabelle Backman (editor)
   Amazon
   P.O. Box 81226
   Seattle, WA 98108-1226
   United States of America

   Email: richanna@amazon.com
   URI:   https://www.amazon.com/


   Justin Richer

   Email: ietf@justin.richer.org


   Manu Sporny
   Digital Bazaar
   203 Roanoke Street W.
   Blacksburg, VA 24060
   United States of America

   Phone: +1 540 961 4469
   Email: msporny@digitalbazaar.com
   URI:   https://manu.sporny.org/

















Backman, et al.           Expires 10 June 2020                 [Page 27]
