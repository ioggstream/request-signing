<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">
<?xml-stylesheet type="text/xsl" href="rfc2629.xsl" ?>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocindent="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<!--
        Note for draft editors and processors â€“ you may see the following warning
        when processing this document through xml2rfc:

            Warning: Setting consensus="true" for IETF STD document (this is not
            the schema default, but is the only value permitted for this type of
            document)

        This appears to be an issue be an issue with a lack of distinction between
        drafts and RFCs. The guidance is to ignore the warning for now.

        See: https://www.rfc-editor.org/materials/FAQ-xml2rfcv3.html#name-how-do-i-fix-common-errors-
     -->
    <rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="std" ipr="trust200902" docName="draft-richanna-http-message-signatures-00" obsoletes="" updates="" submissionType="IETF" xml:lang="en" tocInclude="true" tocDepth="3" symRefs="true" sortRefs="true" version="3">
        <!-- xml2rfc v2v3 conversion 2.35.0 -->
        <front>
            <title>Signing HTTP Messages</title>
            <seriesInfo name="Internet-Draft" value="draft-richanna-http-message-signatures-00"/>
            <author initials="A." surname="Backman" fullname="Annabelle Backman" role="editor">
                <organization>Amazon</organization>
                <address>
                    <postal>
                        <street>P.O. Box 81226</street>
                        <city>Seattle</city>
                        <region>WA</region>
                        <code>98108-1226</code>
                        <country>United States of America</country>
                    </postal>
                    <email>richanna@amazon.com</email>
                    <uri>https://www.amazon.com/</uri>
                </address>
            </author>
            <author initials="J." surname="Richer" fullname="Justin Richer">
                <address>
                    <email>ietf@justin.richer.org</email>
                </address>
            </author>
            <author initials="M." surname="Sporny" fullname="Manu Sporny">
                <organization>Digital Bazaar</organization>
                <address>
                    <postal>
                        <street>203 Roanoke Street W.</street>
                        <city>Blacksburg</city>
                        <region>VA</region>
                        <code>24060</code>
                        <country>United States of America</country>
                    </postal>
                    <phone>+1 540 961 4469</phone>
                    <email>msporny@digitalbazaar.com</email>
                    <uri>https://manu.sporny.org/</uri>
                </address>
            </author>
            <date day="08" month="12" year="2019"/>
            <area>Applications</area>
            <workgroup>HTTPbis Working Group</workgroup>
            <keyword>HTTP</keyword>
            <keyword>digital signature</keyword>
            <keyword>PKI</keyword>
            <abstract>
                <t>This document describes a mechanism for creating, encoding, and verifying digital signatures or message authentication codes over content within an HTTP message.  This mechanism supports use cases where the full HTTP message may not be known to the signer, and where the message may be transformed (e.g., by intermediaries) before reaching the verifier.</t>
            </abstract>
            <note removeInRFC="true">
                <t>This draft is based on draft-cavage-http-signatures-12.  <eref target="https://github.com/w3c-dvcg/http-signatures/issues?page=2&amp;q=is%3Aissue+is%3Aopen">The community</eref> and the authors have identified several issues with the current text.  Additionally, the authors have identified a number of features that are required in order to support additional use cases.  In order to preserve continuity wih the effort that has been put into draft-cavage-http-signatures-12, this draft maintains normative compatibility with it, and thus does not address these issues or include these features, as doing so requires making backwards-incompatible changes to normative requirements.  While such changes are inevitable, the editor recommends that they be driven by working group discussion following adoption of the draft (see <xref target="wg-discuss" format="title"/>).  The editor requests that the working group recognize the intent of this initial draft and this recommendation when considering adoption of this draft.</t>
            </note>
        </front>
        <middle>
            <section anchor="intro">
                <name>Introduction</name>
                <t>Message integrity and authenticity are important security properties that are critical to the secure operation of many <xref target="RFC7230"/> applications.  Application developers typically rely on the transport layer to provide these properties, by operating their application over <xref target="RFC8446">TLS</xref>.  However, TLS only guarantees these properties over a single TLS connection, and the path between client and application may be composed of multiple independent TLS connections (for example, if the application is hosted behind a TLS-terminating gateway or if the client is behind a TLS Inspection appliance).  In such cases, TLS cannot guarantee end-to-end message integrity or authenticity between the client and application.  Additionally, some operating environments present obstacles that make it impractical to use TLS, or to use features necessary to provide message authenticity.  Consequently, while TLS can meet message integrity and authenticity needs for many HTTP-based applications, it is not a universal solution.</t>

                <t>This document defines a mechanism for providing end-to-end integrity and authenticity for content within an HTTP message.  The mechanism allows applications to create digital signatures or message authentication codes (MACs) over only that content within the message that is meaningful and appropriate for the application.  Strict canonicalization rules ensure that the verifier can verify the signature even if the message has been transformed in any of the many ways permitted by HTTP.</t>

                <t>The mechanism described in this document consists of three parts:</t>
                <ul>
                    <li>A common nomenclature and canonicalization rule set for the different protocol elements and other content within HTTP messages.</li>
                    <li>Algorithms for generating and verifying signatures over HTTP message content using this nomenclature and rule set.</li>
                    <li>A mechanism for attaching a signature and related metadata to an HTTP message.</li>
                </ul>

                <section>
                    <name>Requirements Discussion</name>
                    <t>HTTP permits and sometimes requires intermediaries to transform messages in a variety of ways.  This may result in a recipient receiving a message that is not bitwise equivalent to the message that was oringally sent.  In such a case, the recipient will be unable to verify a signature over the raw bytes of the sender's HTTP message, as verifying digital signatures or MACs requires both signer and verifier to have the exact same signed content.  Since the raw bytes of the message cannot be relied upon as signed content, the signer and verifier must derive the signed content from their respective versions of the message, via a mechanism that is resilient to safe changes that do not alter the meaning of the message.</t>
                    <t>For a variety of reasons, it is impractical to strictly define what constitutes a safe change versus an unsafe one.  Applications use HTTP in a wide variety of ways, and may disagree on whether a particular piece of information in a message (e.g., the body, or the Date header field) is relevant.  Thus a general purpose solution must provide signers with some degree of control over which message content is signed.</t>
                    <t>HTTP applications may be running in environments that do not provide complete access to or control over HTTP messages (such as a web browser's JavaScript environment), or may be using libraries that abstract away the details of the protocol (such as <eref target="https://openjdk.java.net/groups/net/httpclient/intro.html">the Java HTTPClient library</eref>).  These applications need to be able to generate and verify signatures despite incomplete knowledge of the HTTP message.</t>
                </section>

                <section anchor="about_sigs">
                    <name>HTTP Message Transformations</name>
                    <t>As mentioned earlier, HTTP explicitly permits and in some cases requires implementations to transform messages in a variety of ways.  Implementations are required to tolerate many of these transformations.  What follows is a non-normative and non-exhaustive list of transformations that may occur under HTTP, provided as context:</t>
                    <ul>
                        <li>Re-ordering of header fields with different header field names (<relref target="RFC7230" section="3.2.2" displayFormat="comma"/>).</li>
                        <li>Combination of header fields with the same field name (<relref target="RFC7230" section="3.2.2" displayFormat="comma"/>).</li>
                        <li>Removal of header fields listed in the <tt>Connection</tt> header field (<relref target="RFC7230" section="6.1" displayFormat="comma"/>).</li>
                        <li>Addition of header fields that indicate control options (<relref target="RFC7230" section="6.1" displayFormat="comma"/>).</li>
                        <li>Addition or removal of a transfer coding (<relref target="RFC7230" section="5.7.2" displayFormat="comma"/>).</li>
                        <li>Addition of header fields such as <tt>Via</tt> (<relref target="RFC7230" section="5.7.1" displayFormat="comma"/>) and <tt>Forwarded</tt> (<relref target="RFC7239" section="4" displayFormat="comma"/>).</li>
                    </ul>
                </section>

                <section>
                    <name>Safe Transformations</name>
                    <t>Based on the definition of HTTP and the requirements described above, we can identify certain types of transformations that should not prevent signature verification, even when performed on content covered by the signature.  The following list describes those transformations:</t>
                    <ul>
                        <li>Combination of header fields with the same field name.</li>
                        <li>Reordering of header fields with different names.</li>
                        <li>Conversion between HTTP/1.x and HTTP/2, or vice-versa.</li>
                        <li>Changes in casing (e.g., "Origin" to "origin") of header field names, request URI scheme or host, or any other case-insensitive content.</li>
                        <li>Addition or removal of leading or trailing whitespace to a header field value.</li>
                        <li>Addition or removal of <tt>obs-fold</tt>s.</li>
                        <li>Changes to the request-target and Host header field that when applied together do not result in a change to the message's effective request URI, as defined in <relref target="RFC7230" section="5.5"/>.</li>
                    </ul>

                    <t>Additionally, all changes to content not covered by the signature are considered safe.</t>
                </section>

            <section anchor="definitions">
                <name>Conventions and Terminology</name>
                <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119">BCP14</xref> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as shown here.</t>

                <t>The terms "HTTP message", "HTTP method", "HTTP request", "HTTP response", <tt>absolute-form</tt>, <tt>absolute-path</tt>, "effective request URI", "gateway", "header field", "intermediary", <tt>request-target</tt>, "sender", and "recipient" are used as defined in <xref target="RFC7230"/>.</t>

                <t>For brevity, the term "signature" on its own is used in this document to refer to both digital signatures and keyed MACs. Similarly, the verb "sign" refers to the generation of either a digital signature or keyed MAC over a given input string. The qualified term "digital signature" refers specifically to the output of an asymmetric cryptographic signing operation.</t>

                <t keepWithNext="true">In addition to those listed above, this document uses the following terms:</t>
                <dl newline="true">
                    <dt>Decimal String</dt><dd>An Integer String optionally concatenated with a period <tt>"."</tt> followed by a second Integer String, representing a positive real number expressed in base 10.  The first Integer String represents the integral portion of the number, while the optional second Integer String represents the fractional portion of the number. [[ Editor's note: There's got to be a definition for this that we can reference. ]]</dd>
                    <dt>Integer String</dt><dd>A US-ASCII string of one or more digits <tt>"0-9"</tt>, representing a positive integer in base 10. [[ Editor's note: There's got to be a definition for this that we can reference. ]]</dd>
                    <dt>Signer</dt><dd>The entity that is generating or has generated an HTTP Message Signature.</dd>
                    <dt>Verifier</dt><dd>An entity that is verifying or has verified an HTTP Message Signature against an HTTP Message.  Note that an HTTP Message Signature may be verified multiple times, potentially by different entities.</dd>
                </dl>
            </section>
        </section>

        <section anchor="content-identifiers">
            <name>Identifying and Canonicalizing Content</name>
            <t>In order to allow signers and verifiers to establish which content is covered by a signature, this document defines content identifiers for signature metadata and discrete pieces of message content that may be covered by an HTTP Message Signature.</t>

            <t>Some content within HTTP messages may undergo transformations that change the bitwise value without altering meaning of the content (for example, the merging together of header fields with the same name).  Message content must therefore be canonicalized before it is signed, to ensure that a signature can be verified despite such innocuous transformations.  This document defines rules for each content identifier that transform the identifier's associated content into such a canonical form.</t>

            <t>The following sections define content identifiers, their associated content, and their canonicalization rules.</t>

            <section>
                <name>HTTP Header Fields</name>
                <t>An HTTP header field value is identified by its header field name.  While HTTP header field names are case-insensitive, implementations <bcp14>SHOULD</bcp14> use lowercased field names (e.g., <tt>content-type</tt>, <tt>date</tt>, <tt>etag</tt>) when using them as content identifiers.</t>

                <t keepWithNext="true">An HTTP header field value is canonicalized as follows:</t>
                <ol>
                    <li>Create an ordered list of the field values of each instance of the header field in the message, in the order that they occur (or will occur) in the messge.</li>
                    <li>Strip leading and trailing whitespace from each item in the list.</li>
                    <li>Concatenate the list items together, with a comma <tt>","</tt> and space <tt>" "</tt> between each item.  The resulting string is the canonicalized value.</li>
                </ol>

                <section toc="exclude">
                    <name>Canonicalization Examples</name>
                    <t keepWithNext="true">This section contains non-normative examples of canonicalized values for header fields, given the following example HTTP message:</t>
                    <sourcecode><![CDATA[
HTTP/1.1 200 OK
Server: www.example.com
Date: Tue, 07 Jun 2014 20:51:35 GMT
X-OWS-Header:   Leading and trailing whitespace.   
X-Obs-Fold-Header: Obsolete  
    line folding.
X-Empty-Header: 
Cache-Control: max-age=60
Cache-Control:    must-revalidate
]]></sourcecode>

                    <t keepWithNext="true">The following table shows example canonicalized values for header fields, given that message:</t>
                    <table>
                        <name>Non-normative examples of header field canoncialization.</name>
                        <thead>
                            <tr><th>Header Field</th><th>Canonicalized Value</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><tt>(cache-control)</tt></td>
                                <td><tt>max-age=60, must-revalidate</tt></td>
                            </tr>
                            <tr>
                                <td><tt>(date)</tt></td>
                                <td><tt>Tue, 07 Jun 2014 20:51:35 GMT</tt></td>
                            </tr>
                            <tr>
                                <td><tt>(server)</tt></td>
                                <td><tt>www.example.com</tt></td>
                            </tr>
                            <tr>
                                <td><tt>(x-empty-header)</tt></td>
                                <td><tt></tt></td>
                            </tr>
                            <tr>
                                <td><tt>(x-obs-fold-header)</tt></td>
                                <td><tt>Obsolete line folding.</tt></td>
                            </tr>
                            <tr>
                                <td><tt>(x-ows-header)</tt></td>
                                <td><tt>Leading and trailing whitespace.</tt></td>
                            </tr>
                        </tbody>
                    </table>
                </section>
            </section>

            <section>
                <name>Signature Creation Time</name>
                <t>The signature's Creation Time (<xref target="signature-metadata"/>) is identified by the <tt>(created)</tt> identifier.</t>

                <t>Its canoncalized value is an Integer String containing the signature's Creation Time expressed as the number of seconds since the Epoch, as defined in <eref target="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_16">Section 4.16</eref> of <xref target="POSIX.1"/>.</t>

                <aside>
                    <t>The use of seconds since the Epoch to canonicalize a timestamp simplifies processing and avoids timezone management required by specifications such as <xref target="RFC3339"/>.</t>
                </aside>
            </section>

            <section>
                <name>Signature Expiration Time</name>
                <t>The signature's Expiration Time (<xref target="signature-metadata"/>) is identified by the <tt>(expired)</tt> identifier.</t>

                <t>Its canonicalized value is a Decimal String containing the signature's Expiration Time expressed as the number of seconds since the Epoch, as defined in <eref target="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_16">Section 4.16</eref> of <xref target="POSIX.1"/>.</t>
            </section>

            <section>
                <name>Target Endpoint</name>
                <t>The request target endpoint, consisting of the request method and the path and query of the effective request URI, is identified by the <tt>(request-target)</tt> identifier.</t>

                <t keepWithNext="true">Its value is canonicalized as follows:</t>
                <ol>
                    <li>Take the lowercased HTTP method of the message.</li>
                    <li>Append a space <tt>" "</tt>.</li>
                    <li>Append the path and query of the request target of the message, formatted according to the rules defined for the <tt>:path</tt> pseudo-header in <xref target="RFC7540" section="8.1.2.3" sectionFormat="comma"/>.  The resulting string is the canonicalized value.</li>
                </ol>

                <section toc="exclude">
                    <name>Canonicalization Examples</name>
                    <t>The following table contains non-normative example HTTP messages and their canonicalized <tt>(request-target)</tt> values.</t>
                    <table>
                        <name>Non-normative examples of <tt>(request-target)</tt> canonicalization.</name>
                        <thead>
                            <tr><th>HTTP Message</th><th><tt>(request-target)</tt></th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><sourcecode><![CDATA[
POST /?param=value HTTP/1.1
Host: www.example.com]]></sourcecode></td>
                                <td><tt>post /?param=value</tt></td>
                            </tr>
                            <tr>
                                <td><sourcecode><![CDATA[
POST /a/b HTTP/1.1
Host: www.example.com]]></sourcecode></td>
                                <td><tt>post /a/b</tt></td>
                            </tr>
                            <tr>
                                <td><sourcecode><![CDATA[
GET http://www.example.com/a/ HTTP/1.1]]></sourcecode></td>
                                <td><tt>get /a/</tt></td>
                            </tr>
                            <tr>
                                <td><sourcecode><![CDATA[
GET http://www.example.com HTTP/1.1]]></sourcecode></td>
                                <td><tt>get /</tt></td>
                            </tr>
                            <tr>
                                <td><sourcecode><![CDATA[
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com]]></sourcecode></td>
                                <td><tt>connect /</tt></td>
                            </tr>
                            <tr>
                                <td><sourcecode><![CDATA[
OPTIONS * HTTP/1.1
Host: server.example.com]]></sourcecode></td>
                                <td><tt>options *</tt></td>
                            </tr>
                        </tbody>
                    </table>
                </section>
            </section>
        </section>

        <section anchor="message-signatures">
            <name>HTTP Message Signatures</name>
            <t>An HTTP Message Signature is a signature over a string generated from a subset of the content in an HTTP message and metadata about the signature itself.  When successfully verified against an HTTP message, it provides cryptographic proof that with respect to the subset of content that was signed, the message is semantically equivalent to the message for which the signature was generated.</t>

            <section anchor="signature-metadata">
                <name>Signature Metadata</name>
                <t keepWithNext="true">HTTP Message Signatures have metadata properties that provide information regarding the signature's generation and/or verification.  The following metadata properties are defined:</t>
                <dl newline="true">
                    <dt>Algorithm</dt>
                    <dd>An HTTP Signature Algorithm defined in the <xref target="hsa-registry" format="title"/> defined in this document.  It describes the signing and verification algorithms for the signature.</dd>
                    <dt>Creation Time</dt>
                    <dd>A timestamp representing the point in time that the signature was generated.  Sub-second precision is not supported.  A signature's Creation Time <bcp14>MAY</bcp14> be undefined, indicating that it is unknown.</dd>
                    <dt>Covered Content</dt>
                    <dd>An ordered list of content identifiers (<xref target="content-identifiers" />) that indicates the metadata and message content that is covered by the signature.  The order of identifiers in this list affects signature generation and verification, and therefore <bcp14>MUST</bcp14> be preserved.</dd>
                    <dt>Expiration Time</dt>
                    <dd>A timestamp representing the point in time at which the signature expires.  An expired signature always fails verification.  A signature's Expiration Time <bcp14>MAY</bcp14> be undefined, indicating that the signature does not expire.</dd>
                    <dt>Verification Key Material</dt>
                    <dd><t>The key material required to verify the signature.</t></dd>
                </dl>
            </section>

            <section anchor="create">
                <name>Creating a Signature</name>
                <t>In order to create a signature, a signer completes the following process:</t>
                <ol>
                    <li>Choose key material and algorithm, and set metadata properties (<xref target="choose-metadata"/>)</li>
                    <li>Create the Signature Input (<xref target="canonicalization"/>)</li>
                    <li>Sign the Signature Input (<xref target="sign-sig-input"/>)</li>
                </ol>

                <t>The following sections describe each of these steps in detail.</t>

                <section anchor="choose-metadata">
                    <name>Choose and Set Signature Metadata Properties</name>
                    <ol>
                        <li>The signer chooses an HTTP Signature Algorithm from those registered in the <xref target="hsa-registry" format="title"/> defined by this document, and sets the signature's Algorithm property to that value.  The signer <bcp14>MUST NOT</bcp14> choose an algorithm marked "Deprecated".  The mechanism by which the signer chooses an algorithm is out of scope for this document.</li>

                        <li>The signer chooses key material to use for signing and verification, and sets the signature's Verification Key Material property to the key material required for verification.  The signer <bcp14>MUST</bcp14> choose key material that is appropriate for the signature's Algorithm, and that conforms to any requirements defined by the Algorithm, such as key size or format.  The mechanism by which the signer chooses key material is out of scope for this document.</li>

                        <li>The signer sets the signature's Creation Time property to the current time.</li>

                        <li>The signer sets the signature's Expiration Time property to the time at which the signature is to expire, or to undefined if the signature will not expire.</li>

                        <li>The signer creates an ordered list of content identifiers representing the message content and signature metadata to be covered by the signature, and assigns this list as the signature's Covered Content.  Each identifier <bcp14>MUST</bcp14> be one of those defined in <xref target="content-identifiers"/>.  This list <bcp14>MUST NOT</bcp14> be empty, as this would result in creating a signature over the empty string.  If the signature's Algorithm name does not start with <tt>rsa</tt>, <tt>hmac</tt>, or <tt>ecdsa</tt>, signers <bcp14>SHOULD</bcp14> include <tt>(created)</tt> and <tt>(request-target)</tt> in the list.  If the signature's Algorithm starts with <tt>rsa</tt>, <tt>hmac</tt>, or <tt>ecdsa</tt>, signers <bcp14>SHOULD</bcp14> include <tt>date</tt> and <tt>(request-target)</tt> in the list.  Further guidance on what to include in this list and in what order is out of scope for this document.  However, the list order is significant and once established for a given signature it <bcp14>MUST</bcp14> be preserved for that signature.</li>
                    </ol>
                </section>

                <section anchor="canonicalization">
                    <name>Create the Signature Input</name>
                    <t>The Signature Input is a US-ASCII string containing the content that will be signed.  To create it, the signer concatenates together entries for each identifier in the signature's Covered Content in the order it occurs in the list, with each entry separated by a newline <tt>"\n"</tt>.  An identifier's entry is a US-ASCII string consisting of the lowercased identifier followed with a colon <tt>":"</tt>, a space <tt>" "</tt>, and the identifier's canonicalized value (described below).</t>

                    <t>If Covered Content contains <tt>(created)</tt> and the signature's Creation Time is undefined or the signature's Algorithm name starts with <tt>rsa</tt>, <tt>hmac</tt>, or <tt>ecdsa</tt> an implementation <bcp14>MUST</bcp14> produce an error.</t>

                    <t>If Covered Content contains <tt>(expires)</tt> and the signature does not have an Expiration Time or the signature's Algorithm name starts with <tt>rsa</tt>, <tt>hmac</tt>, or <tt>ecdsa</tt> an implementation <bcp14>MUST</bcp14> produce an error.</t>

                    <t>If Covered Content contains an identifier for a header field that is not present or malformed in the message, the implementation <bcp14>MUST</bcp14> produce an error.</t>

                    <t keepWithNext="true">To illustrate the rules specified above, assume the signature's Covered Content is a list containing <tt>(request-target)</tt>, <tt>(created)</tt>, <tt>host</tt>, <tt>date</tt>, <tt>cache-control</tt>, <tt>x-emptyheader</tt>, and <tt>x-example</tt>, in order, the signature's Creation Time is equal to the value of the message's Date header, and the following HTTP message:</t>
                    <sourcecode><![CDATA[
GET /foo HTTP/1.1
Host: example.org
Date: Tue, 07 Jun 2014 20:51:35 GMT
X-Example: Example header
        with some whitespace.
X-EmptyHeader:
Cache-Control: max-age=60
Cache-Control: must-revalidate]]></sourcecode>
                    <t keepWithNext="true">For the HTTP message above, the corresponding Signature Input is:</t>
                    <sourcecode><![CDATA[
(request-target): get /foo
(created): 1402170695
host: example.org
date: Tue, 07 Jun 2014 20:51:35 GMT
cache-control: max-age=60, must-revalidate
x-emptyheader:
x-example: Example header with some whitespace.]]></sourcecode>
                </section>

                <section anchor="sign-sig-input">
                    <name>Sign the Signature Input</name>
                    <t>The signer signs the Signature Input using the signing algorithm described by the signature's Algorithm property, and the key material chosen by the signer.  The signer then encodes the result of that operation as a base 64-encoded string <xref target="RFC4648"/>.  This string is the signature value.</t>

                    <t>For example, assume that the Algorithm is "hs2019" and the key is an EdDSA private key.  This would signal to the application that the the signing algorithm is Ed25519 as defined in <xref target="RFC8032" section="5.1" sectionFormat="comma">RFC 8032</xref>.  The result of the signing algorithm should be a binary string, which once base 64 encoded becomes the signature value.</t>
                </section>
            </section>

            <section anchor="verify">
                <name>Verifying a Signature</name>
                <t>In order to verify a signature, a verifier <bcp14>MUST</bcp14>:</t>
                <ol>
                    <li>Use the received HTTP message and the signature's metadata to recreate the Signature Input, using the process described in <xref target="canonicalization"/>.</li>
                    <li>Use the signature's Algorithm and Verification Key Material with the recreated Signing Input to verify the signature value.</li>
                </ol>

                <t>A signature with a Creation Time that is in the future or an Expiration Time that is in the past <bcp14>MUST NOT</bcp14> be processed.</t>

                <t>The verifier <bcp14>MUST</bcp14> ensure that a signature's Algorithm is appropriate for the key material the verifier will use to verify the signature.  If the Algorithm is not appropriate for the key material (for example, if it is the wrong size, or in the wrong format), the signature <bcp14>MUST NOT</bcp14> be processed.</t>

                <t>For example, assume that the Algorithm was "hs2019" and the Verification Key Material is an EdDSA public key.  This would signal to the application that the signing algorithm is Ed25519 as defined in <xref target="RFC8032" section="5.1" sectionFormat="comma">RFC 8032</xref>.  The result of the signature verification algorithm should result in a successful verification unless the message content or signature metadata protected by the signature were tampered with in transit.</t>
            </section>
        </section>

        <section anchor="sig">
            <name>The 'Signature' HTTP Header</name>
            <t>The "Signature" HTTP header provides a mechanism to attach a signature to the HTTP message from which it was generated.  The header field name is "Signature" and its value is a list of parameters and values, formatted according to the <tt>signature</tt> syntax defined below, using the extended Augmented Backus-Naur Form (ABNF) notation used in <xref target="RFC7230"/>.</t>

            <sourcecode><![CDATA[
signature    = #( sig-param )

sig-param    = token BWS "=" BWS ( token / quoted-string )]]></sourcecode>

            <t>Each <tt>sig-param</tt> is a parameter defined in <xref target="params"/>.</t>

            <section anchor="params">
                <name>Signature Header Parameters</name>
                <t>The Signature header's parameters contain the signature value itself and the signature metadata properties required to verify the signature.  Unless otherwise specified, parameters <bcp14>MUST NOT</bcp14> occur multiple times in one header, whether with the same or different values.  The following parameters are defined:</t>

                <dl newline="true">
                    <dt anchor="algorithm"><tt>algorithm</tt></dt>
                    <dd>
                        <t><bcp14>RECOMMENDED</bcp14>.  The <tt>algorithm</tt> parameter contains the name of the signature's Algorithm, as registered in the <xref target="hsa-registry" format="title"/> defined by this document.  Verifiers <bcp14>MUST</bcp14> determine the signature's Algorithm from the <tt>keyId</tt> parameter rather than from <tt>algorithm</tt>.  If <tt>algorithm</tt> is provided and differs from or is incompatible with the algorithm or key material identified by <tt>keyId</tt> (for example, <tt>algorithm</tt> has a value of <tt>rsa-sha256</tt> but <tt>keyId</tt> identifies an EdDSA key), then implementations <bcp14>MUST</bcp14> produce an error.  Implementers should note that previous versions of this specification determined the signature's Algorithm using the <tt>algorithm</tt> parameter only, and thus could be utilized by attackers to expose security vulnerabilities.</t>
                    </dd>

                    <dt anchor="created"><tt>created</tt></dt>
                    <dd><bcp14>RECOMMENDED</bcp14>.  The <tt>created</tt> parameter contains the signature's Creation Time, expressed as the canonicalized value of the <tt>(created)</tt> content identifier, as defined in <xref target="content-identifiers"/>.  If not specified, the signature's Creation Time is undefined.  This parameter is useful when signers are not capable of controlling the <tt>Date</tt> HTTP Header such as when operating in certain web browser environments.</dd>

                    <dt anchor="expires"><tt>expires</tt></dt>
                    <dd><bcp14>OPTIONAL</bcp14>.  The <tt>expires</tt> parameter contains the signature's Expiration Time, expressed as the canonicalized value of the <tt>(expires)</tt> content identifier, as defined in <xref target="content-identifiers"/>.  If the signature does not have an Expiration Time, this parameter <tt>MUST</tt> be omitted.</dd>

                    <dt anchor="headers"><tt>headers</tt></dt>
                    <dd><bcp14>OPTIONAL</bcp14>.  The <tt>headers</tt> parameter contains the signature's Covered Content, expressed as a string containing a quoted list of the identifiers in the list, in the order they occur in the list, with a space <tt>" "</tt> between each identifier.  If specified, identifiers for header fields <bcp14>SHOULD</bcp14> be lowercased and all others <bcp14>MUST</bcp14> be lowercased.  If not specified, verifiers <bcp14>MUST</bcp14> assume the signature's Covered Content is a list containing only a single <tt>(created)</tt> identifier.</dd>

                    <dt anchor="keyId"><tt>keyId</tt></dt>
                    <dd><bcp14>REQUIRED</bcp14>.  The <tt>keyId</tt> parameter is a US-ASCII string whose value can be used by a verifier to identify and/or obtain the signature's <tt>Verification Key Material</tt>.  The format and semantics of this value are out of scope for this document.</dd>

                    <dt anchor="signature"><tt>signature</tt></dt>
                    <dd><bcp14>REQUIRED</bcp14>.  The <tt>signature</tt> parameter contains the signature value, as described in <xref target="sign-sig-input"/>.</dd>
                </dl>
            </section>

            <section>
                <name>Examples</name>
                <t keepWithNext="true">The following non-normative examples are based on the following HTTP message:</t>
                <sourcecode><![CDATA[
POST /foo HTTP/1.1
Host: example.com
Date: Tue, 07 Jun 2014 20:51:35 GMT
Content-Type: application/json
Digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
Content-Length: 18

{"hello": "world"}]]></sourcecode>

                <t>The following examples assume that the "rsa-key-1" keyId provided by the signer is meaningful to the verifier.  Note that to improve readability, some header values are split into multiple lines, using the <tt>obs-fold</tt> syntax.  This syntax is deprecated in <xref target="RFC7230"/>, and senders <bcp14>MUST NOT</bcp14> generate messages that include it.</t>

                <section anchor="sig-rsa-example">
                    <name>RSA Example</name>
                    <t keepWithNext="true">The signature header and signature would be generated as:</t>
                    <sourcecode><![CDATA[
Signature: keyId="rsa-key-1",algorithm="hs2019",
    created=1402170695, expires=1402170995,
    headers="(request-target) (created) (expires)
        host date digest content-length",
    signature="Base64(RSA-SHA256(signing string))"]]></sourcecode>

                    <t keepWithNext="true">To verify the signature, a verifier would compose the Signature Input as:</t>
                    <sourcecode><![CDATA[
(request-target): post /foo
(created): 1402170695
(expires): 1402170995
host: example.org
digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
content-length: 18]]></sourcecode>
                </section>

                <section anchor="sig-hmac-example">
                    <name>HMAC Example</name>
                    <t keepWithNext="true">For an HMAC-based signature without a list of headers specified, the authorization header and signature would be generated as:</t>
                    <sourcecode><![CDATA[
Signature: keyId="hmac-key-1",algorithm="hs2019",created=1402170695,
    headers="(request-target) (created) host digest content-length",
    signature="Base64(HMAC-SHA512(signing string))"]]></sourcecode>
                    <t keepWithNext="true">The only difference between the RSA Example and the HMAC Example is the signature algorithm that is used.  The verifier would compose the Signature Input in the same way as the RSA Example above:</t>
                    <sourcecode><![CDATA[
(request-target): post /foo\n
(created): 1402170695
host: example.org\n
digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=\n
content-length: 18]]></sourcecode>
                </section>
            </section>
        </section>

        <section anchor="iana">
            <name>IANA Considerations</name>
            <section anchor="hsa-registry">
                <name>HTTP Signature Algorithms Registry</name>
                <t>This document defines HTTP Signature Algorithms, for which IANA is asked to create and maintain a new registry titled "HTTP Signature Algorithms".  Initial values for this registry are given in <xref target="iana-hsa-contents"/>.  Future assignments and modifications to existing assignment are to be made through the Expert Review registration policy <xref target="RFC8126"/> and shall follow the template presented in <xref target="iana-hsa-template" />.</t>

                <section anchor="iana-hsa-template">
                    <name>Registration Template</name>
                    <dl newline="true">
                        <dt>Algorithm Name</dt>
                        <dd>An identifier for the HTTP Signature Algorithm.  The name <bcp14>MUST</bcp14> be an ASCII string consisting only of lower-case characters (<tt>"a"</tt> - <tt>"z"</tt>), digits (<tt>"0"</tt> - <tt>"9"</tt>), and hyphens (<tt>"-"</tt>), and <bcp14>SHOULD NOT</bcp14> exceed 20 characters in length.  The identifier <bcp14>MUST</bcp14> be unique within the context of the registry.</dd>
                        <dt>Status</dt>
                        <dd>A brief text description of the status of the algorithm.  The description <bcp14>MUST</bcp14> begin with one of "Active" or "Deprecated", and <bcp14>MAY</bcp14> provide further context or explanation as to the reason for the status.</dd>
                        <dt>Description</dt>
                        <dd>A description of the algorithm used to sign the signing string when generating an HTTP Message Signature, or instructions on how to determine that algorithm. When the description specifies an algorithm, it <bcp14>MUST</bcp14> include a reference to the document or documents that define the algorithm.</dd>
                    </dl>
                </section>

                <section anchor="iana-hsa-contents">
                    <name>Initial Contents</name>
                    <t>[[ MS: The references in this section are problematic as many of the specifications that they refer to are too implementation specific, rather than just pointing to the proper signature and hashing specifications.  A better approach might be just specifying the signature and hashing function specifications, leaving implementers to connect the dots (which are not that hard to connect). ]]</t>

                    <section numbered="false">
                        <name><tt>hs2019</tt></name>
                        <dl newline="true">
                            <dt>Algorithm Name</dt>
                            <dd><tt>hs2019</tt></dd>
                            <dt>Status</dt>
                            <dd>active</dd>
                            <dt>Description</dt>
                            <dd>
                                <t keepWithNext="true">Derived from metadata associated with <tt>keyId</tt>.  Recommend support for:</t>
                                <ul>
                                    <li>RSASSA-PSS <xref target="RFC8017"/> using SHA-512 <xref target="RFC6234"/></li>
                                    <li>HMAC <xref target="RFC2104"/> using SHA-512 <xref target="RFC6234"/></li>
                                    <li>ECDSA using curve P-256 <xref target="FIPS186-4"/> and SHA-512 <xref target="RFC6234"/></li>
                                    <li>Ed25519ph, Ed25519ctx, and Ed25519 <xref target="RFC8032"/></li>
                                </ul>
                            </dd>
                        </dl>
                    </section>

                    <section numbered="false">
                        <name><tt>rsa-sha1</tt></name>
                        <dl newline="true">
                            <dt>Algorithm Name</dt>
                            <dd><tt>rsa-sha1</tt></dd>
                            <dt>Status</dt>
                            <dd>Deprecated; SHA-1 not secure.</dd>
                            <dt>Description</dt>
                            <dd>RSASSA-PKCS1-v1_5 <xref target="RFC8017"/> using SHA-1 <xref target="RFC6234"/></dd>
                        </dl>
                    </section>

                    <section numbered="false">
                        <name><tt>rsa-sha256</tt></name>
                        <dl newline="true">
                            <dt>Algorithm Name</dt>
                            <dd><tt>rsa-sha256</tt></dd>
                            <dt>Status</dt>
                            <dd>Deprecated; specifying signature algorithm enables attack vector.</dd>
                            <dt>Description</dt>
                            <dd>RSASSA-PKCS1-v1_5 <xref target="RFC8017"/> using SHA-256 <xref target="RFC6234"/></dd>
                        </dl>
                    </section>

                    <section numbered="false">
                        <name><tt>hmac-sha256</tt></name>
                        <dl newline="true">
                            <dt>Algorithm Name</dt>
                            <dd><tt>hmac-sha256</tt></dd>
                            <dt>Status</dt>
                            <dd>Deprecated; specifying signature algorithm enables attack vector.</dd>
                            <dt>Description</dt>
                            <dd>HMAC <xref target="RFC2104"/> using SHA-256 <xref target="RFC6234"/></dd>
                        </dl>
                    </section>

                    <section numbered="false">
                        <name><tt>ecdsa-sha256</tt></name>
                        <dl newline="true">
                            <dt>Algorithm Name</dt>
                            <dd><tt>ecdsa-sha256</tt></dd>
                            <dt>Status</dt>
                            <dd>Deprecated; specifying signature algorithm enables attack vector.</dd>
                            <dt>Description</dt>
                            <dd>ECDSA using curve P-256 <xref target="FIPS186-4"/> and SHA-256 <xref target="RFC6234"/></dd>
                        </dl>
                    </section>
                </section>
            </section>
        </section>

        <section anchor="security">
            <name>Security Considerations</name>
            <t>[[ Editor's note: TODO: need to dive deeper on this section; not sure how much of what's referenced below is actually applicable, or if it covers everything we need to worry about. ]]</t>
            <t>There are a number of security considerations to take into account when implementing or utilizing this specification.  A thorough security analysis of this protocol, including its strengths and weaknesses, can be found in <xref target="WP-HTTP-Sig-Audit">Security Considerations for HTTP Signatures</xref>.</t>
        </section>
    </middle>
    <back>
        <displayreference target="FIPS186-4" to="DSS"/>
        <displayreference target="RFC7230" to="HTTP"/>
        <displayreference target="RFC7540" to="HTTP2"/>
        <displayreference target="RFC8126" to="BCP 26"/>
        <references>
            <name>References</name>
            <references>
                <name>Normative References</name>
                <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2104.xml"/>
                <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
                <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3986.xml"/>
                <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4648.xml"/>
                <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7230.xml"/>
                <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7540.xml"/>
                <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7541.xml"/>
                <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>
                <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
                <reference anchor="FIPS186-4" target="https://csrc.nist.gov/publications/detail/fips/186/4/final">
                    <front>
                        <title>Digital Signature Standard (DSS)</title>
                        <author><organization>NIST</organization></author>
                        <date month="07" year="2013"/>
                    </front>
                    <seriesInfo name="FIPS" value="186-4"/>
                    <seriesInfo name="DOI" value="10.6028/NIST.FIPS.186-4"/>
                </reference>
                <reference anchor="POSIX.1" target="https://pubs.opengroup.org/onlinepubs/9699919799/">
                    <front>
                        <title>The Open Group Base Specifications Issue 7, 2018 edition</title>
                        <author><organization>IEEE</organization></author>
                        <author><organization>The Open Group</organization></author>
                        <date year="2018"/>
                    </front>
                    <seriesInfo name="IEEE Std" value="1003.1-2017"/>
                </reference>
            </references>
            <references>
                <name>Informative References</name>
                <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3339.xml"/>
                <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6234.xml"/>
                <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7239.xml"/>
                <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7518.xml"/>
                <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8017.xml"/>
                <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8032.xml"/>
                <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml"/>
                <reference anchor="WP-HTTP-Sig-Audit" target="https://web-payments.org/specs/source/http-signatures-audit/">
                    <front>
                        <title>Security Considerations for HTTP Signatures</title>
                        <author initials="M." surname="Sporny" fullname="Manu Sporny"/>
                        <date month="June" year="2013"/>
                    </front>
                </reference>
            </references>
        </references>

        <section>
            <name>Examples</name>
            <t keepWithNext="true">The examples in this section use the following RSA 2048-bit keys, which we will refer to as <tt>keyId=Test</tt>:</t>
            <sourcecode><![CDATA[
-----BEGIN RSA PUBLIC KEY-----
MIIBCgKCAQEAhAKYdtoeoy8zcAcR874L8cnZxKzAGwd7v36APp7Pv6Q2jdsPBRrw
WEBnez6d0UDKDwGbc6nxfEXAy5mbhgajzrw3MOEt8uA5txSKobBpKDeBLOsdJKFq
MGmXCQvEG7YemcxDTRPxAleIAgYYRjTSd/QBwVW9OwNFhekro3RtlinV0a75jfZg
kne/YiktSvLG34lw2zqXBDTC5NHROUqGTlML4PlNZS5Ri2U4aCNx2rUPRcKIlE0P
uKxI4T+HIaFpv8+rdV6eUgOrB2xeI1dSFFn/nnv5OoZJEIB+VmuKn3DCUcCZSFlQ
PSXSfBDiUGhwOw76WuSSsf1D4b/vLoJ10wIDAQAB
-----END RSA PUBLIC KEY-----

-----BEGIN RSA PRIVATE KEY-----
MIIEqAIBAAKCAQEAhAKYdtoeoy8zcAcR874L8cnZxKzAGwd7v36APp7Pv6Q2jdsP
BRrwWEBnez6d0UDKDwGbc6nxfEXAy5mbhgajzrw3MOEt8uA5txSKobBpKDeBLOsd
JKFqMGmXCQvEG7YemcxDTRPxAleIAgYYRjTSd/QBwVW9OwNFhekro3RtlinV0a75
jfZgkne/YiktSvLG34lw2zqXBDTC5NHROUqGTlML4PlNZS5Ri2U4aCNx2rUPRcKI
lE0PuKxI4T+HIaFpv8+rdV6eUgOrB2xeI1dSFFn/nnv5OoZJEIB+VmuKn3DCUcCZ
SFlQPSXSfBDiUGhwOw76WuSSsf1D4b/vLoJ10wIDAQABAoIBAG/JZuSWdoVHbi56
vjgCgkjg3lkO1KrO3nrdm6nrgA9P9qaPjxuKoWaKO1cBQlE1pSWp/cKncYgD5WxE
CpAnRUXG2pG4zdkzCYzAh1i+c34L6oZoHsirK6oNcEnHveydfzJL5934egm6p8DW
+m1RQ70yUt4uRc0YSor+q1LGJvGQHReF0WmJBZHrhz5e63Pq7lE0gIwuBqL8SMaA
yRXtK+JGxZpImTq+NHvEWWCu09SCq0r838ceQI55SvzmTkwqtC+8AT2zFviMZkKR
Qo6SPsrqItxZWRty2izawTF0Bf5S2VAx7O+6t3wBsQ1sLptoSgX3QblELY5asI0J
YFz7LJECgYkAsqeUJmqXE3LP8tYoIjMIAKiTm9o6psPlc8CrLI9CH0UbuaA2JCOM
cCNq8SyYbTqgnWlB9ZfcAm/cFpA8tYci9m5vYK8HNxQr+8FS3Qo8N9RJ8d0U5Csw
DzMYfRghAfUGwmlWj5hp1pQzAuhwbOXFtxKHVsMPhz1IBtF9Y8jvgqgYHLbmyiu1
mwJ5AL0pYF0G7x81prlARURwHo0Yf52kEw1dxpx+JXER7hQRWQki5/NsUEtv+8RT
qn2m6qte5DXLyn83b1qRscSdnCCwKtKWUug5q2ZbwVOCJCtmRwmnP131lWRYfj67
B/xJ1ZA6X3GEf4sNReNAtaucPEelgR2nsN0gKQKBiGoqHWbK1qYvBxX2X3kbPDkv
9C+celgZd2PW7aGYLCHq7nPbmfDV0yHcWjOhXZ8jRMjmANVR/eLQ2EfsRLdW69bn
f3ZD7JS1fwGnO3exGmHO3HZG+6AvberKYVYNHahNFEw5TsAcQWDLRpkGybBcxqZo
81YCqlqidwfeO5YtlO7etx1xLyqa2NsCeG9A86UjG+aeNnXEIDk1PDK+EuiThIUa
/2IxKzJKWl1BKr2d4xAfR0ZnEYuRrbeDQYgTImOlfW6/GuYIxKYgEKCFHFqJATAG
IxHrq1PDOiSwXd2GmVVYyEmhZnbcp8CxaEMQoevxAta0ssMK3w6UsDtvUvYvF22m
qQKBiD5GwESzsFPy3Ga0MvZpn3D6EJQLgsnrtUPZx+z2Ep2x0xc5orneB5fGyF1P
WtP+fG5Q6Dpdz3LRfm+KwBCWFKQjg7uTxcjerhBWEYPmEMKYwTJF5PBG9/ddvHLQ
EQeNC8fHGg4UXU8mhHnSBt3EA10qQJfRDs15M38eG2cYwB1PZpDHScDnDA0=
-----END RSA PRIVATE KEY-----]]></sourcecode>

            <t keepWithNext="true">All examples use this HTTP message:</t>
            <sourcecode><![CDATA[
POST /foo?param=value&pet=dog HTTP/1.1
Host: example.com
Date: Sun, 05 Jan 2014 21:31:40 GMT
Content-Type: application/json
Digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
Content-Length: 18

{"hello": "world"}]]></sourcecode>

            <section anchor="default-test">
                <name>Default Test</name>
                <t keepWithNext="true">[[ Editor's note: This statement about default Covered Content is inaccurate. ]]  If a list of headers is not included, the Date header is the only header that is signed by default for <tt>rsa-sha256</tt>.  The string to sign would be:</t>
                <sourcecode><![CDATA[
date: Sun, 05 Jan 2014 21:31:40 GMT]]></sourcecode>
                <t keepWithNext="true">The Signature header would be:</t>
                <sourcecode><![CDATA[
Signature: keyId="Test",algorithm="rsa-sha256",
    signature="R1ngRJLqHG6A7w0XR2JFCgLrQbIK7gVp/IkzS1zYbDA4mJbkR06Od
    GCS/rLNNcqNOW02Ca2fjeKz9qGfVYzqBUeJJJhvqitB7d0GHxNf1ZvlfWoQlWx0Q
    o3c1e7jhn7hlGe28d3qdfmMO4lxcv8acbB5Xo9MDu/gLgLuPPG2iCViS9SnZjwgQ
    ZdeWc6H7hSw8y8myA8yvc9P7LtEBJzHLxvFCW739nxTLNDxuIHcECtreP9Z+gAcW
    ZnJ59yXmF6kjTQnWUmCSzP1zqraF0eODgfXvejjzILxjZ1nI3RrioOwRtbT2DH5j
    BLi6MlAQh/dkG14/ucZyb0yrEBrqRd6ig=="]]></sourcecode>
            </section>

            <section anchor="basic-test">
                <name>Basic Test</name>
                <t keepWithNext="true">[[ Editor's note: This statement about minimum recommended Covered Content is inaccurate. ]]  The minimum recommended data to sign is the <tt>(request-target)</tt>, <tt>host</tt>, and <tt>date</tt>.  In this case, the string to sign would be:</t>
                <sourcecode><![CDATA[
(request-target): post /foo?param=value&pet=dog
host: example.com
date: Sun, 05 Jan 2014 21:31:40 GMT]]></sourcecode>
                <t keepWithNext="true">The Signature header would be:</t>
                <sourcecode><![CDATA[
Signature: keyId="Test",algorithm="rsa-sha256",
    headers="(request-target) host date",
    signature="TSkjEULCH2HKgS23CF9E6pFfoFnCOOmPqYqlytuTgh/4agD2x2pbJ
    SaAiOaj1ct0zxY1nmBWEs3RNzEURNFPHcwTyK2e9HqpMeHtzz9U8us9UWmE/SJiE
    fsp4C3dORtjuN1cGHQ9mEfiDStb/ucSGrBIrmSP4hIFGlJjzOIiFFDqxppHmpWag
    9zELYUMq0nXryKYProoyssryOvzuwTM0mNWU/KEsxCpYqDsFXxY9A/ayHSrQlqMh
    xhGLtcSz2kLSoKj0+hM/gJLC6UFC1Okd1ljhsWIax/N3octJC5A53saETcsLtzrz
    ecei1JNdJctO7VVRIbglHNuNqRs7XwOBg=="]]></sourcecode>
            </section>

            <section anchor="all-headers-test">
                <name>All Headers Test</name>
                <t keepWithNext="true">A strong signature including all of the headers and a digest of the body of the HTTP request would result in the following signing string:</t>
                <sourcecode><![CDATA[
(request-target): post /foo?param=value&pet=dog
host: example.com
date: Sun, 05 Jan 2014 21:31:40 GMT
content-type: application/json
digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
content-length: 18]]></sourcecode>
                <t keepWithNext="true">The Signature header would be:</t>
                <sourcecode><![CDATA[
Signature: keyId="Test",algorithm="rsa-sha256",
    created=1402170695, expires=1402170699,
    headers="(request-target) (created) (expires)
    host date content-type digest content-length",
    signature="DCx3tr/0pZU+ecTOrnXzWMtv/OYDl5PMJUIdd4ApuZCk8vb0QlFga
    FFPreMUG33g7IO/4zH56Ld67vTLyjIQcDxYK/ad42EqkSrzainPYt0lpOPLUwxj6
    ZCM9NWAqrBvkQGRo4y+OcAFPfGDSNJw95CwHICL50rm7VCLP5rVhSt7TM1Qd2STY
    HoNb2BnwVEAkWemI68aZQaUD3uwH01I71EPrMAo8YHULeKPyOwpJowMBCDWl9061
    2qy7UCUlz86bBRqqVIyPI9/5NV50UGP1QBtD61iXKUh0n3KcAHbODyO8+AVtnWAB
    rlhceJEwvmhBak8LAdGTlY4EGOrHeeLLQ=="]]></sourcecode>
            </section>
        </section>

        <section anchor="wg-discuss" removeInRFC="true">
            <name>Topics for Working Group Discussion</name>
            <t>The editor recommends the working group discuss the issues and features described in this section, after adoption of the document by the working group.  Topics are not listed in any particular order.</t>

            <section>
                <name>Issues</name>
                <section anchor="issue-alg-keyid">
                    <name>Confusing guidance on algorithm and key identification</name>
                    <t>The current draft encourages determining the Algorithm metadata property from the <tt>keyId</tt> field, both in the guidance for the use of <tt>algorithm</tt> and <tt>keyId</tt>, and the definition for the <tt>hs2019</tt> algorithm and deprecation of the other algorithms in the registry.  The current state arose from concern that a malicious party could change the value of the <tt>algorithm</tt> parameter, potentially tricking the verifier into accepting a signature that would not have been verified under the actual parameter.</t>
                    <t>Punting algorithm identification into <tt>keyId</tt> hurts interoperability, since we aren't defining the syntax or semantics of <tt>keyId</tt>.  It actually goes against that claim, as we are dictating that the signing algorithm must be specified by <tt>keyId</tt> or derivable from it.  It also renders the algorithm registry essentially useless.  Instead of this approach, we can protect against manipulation of the Signature header field by adding support for (and possibly mandating) including Signature metadata within the Signature Input.</t>
                </section>

                <section>
                    <name>Lack of definition of <tt>keyId</tt> hurts interoperability</name>
                    <t>The current text leaves the format and semantics of <tt>keyId</tt> completely up to the implementation.  This is primarily due to the fact that most implementers of Cavage have extensive investment in key distribution and management, and just need to plug an identifier into the header.  We should support those cases, but we also need to provide guidance for the developer that doesn't have that and just wants to know how to identify a key.  It may be enough to punt this to profiling specs, but this needs to be explored more.</t>
                </section>

                <section>
                    <name>Algorithm Registry duplicates work of JWA</name>
                    <t><xref target="RFC7518">JSON Web Algorithms (JWA)</xref> already defines an IANA registry for cryptographic algorithms.  This wasn't used by Cavage out of concerns about complexity of JOSE, and issues with JWE and JWS being too flexible, leading to insecure combinations of options.  Using JWA's definitions does not need to mean we're using JOSE, however.  We should look at if/how we can leverage JWA's work without introducing too many sharp edges for implementers.</t>
                </section>

                <section>
                    <name>Algorithm Registry should not be initialized with deprecated entries</name>
                    <t>The initial entries in this document reflect those in Cavage.  The ones that are marked deprecated were done so because of the issue explained in <xref target="issue-alg-keyid"/>, with the possible exception of <tt>rsa-sha1</tt>.  We should probably just remove that one.</t>
                </section>

                <section>
                    <name>No percent-encoding normalization of path/query</name>
                    <t>See: <eref target="https://github.com/w3c-dvcg/http-signatures/issues/26">issue #26</eref></t>

                    <t>The canonicalization rules for <tt>(request-target)</tt> do not perform handle minor, semantically meaningless differences in percent-encoding, such that verification could fail if an intermediary normalizes the effective request URI prior to forwarding the message.</t>

                    <t>At a minimum, they should be case and percent-encoding normalized as described in sections <relref target="RFC3986" section="6.2.2.1" displayFormat="bare"/> and <relref target="RFC3986" section="6.2.2.2" displayFormat="bare"/> of <xref target="RFC3986"/>.</t>
                </section>

                <section>
                    <name>Misleading name for <tt>headers</tt> parameter</name>
                    <t>The Covered Content list contains identifiers for more than just headers, so the <tt>header</tt> parameter name is no longer appropriate.  Some alternatives: "content", "signed-content", "covered-content".</t>
                </section>

                <section>
                    <name>Changes to whitespace in header field values break verification</name>
                    <t>Some header field values contain RWS, OWS, and/or BWS.  Since the header field value canonicalization rules do not address whitespace, changes to it (e.g., removing OWS or BWS or replacing strings of RWS with a single space) can cause verification to fail.</t>
                </section>

                <section>
                    <name>Multiple Set-Cookie headers are not well supported</name>
                    <t>The Set-Cookie header can occur multiple times but does not adhere to the list syntax, and thus is not well supported by the header field value concatenation rules.</t>
                </section>

                <section>
                    <name>Covered Content list is not signed</name>
                    <t>The Covered Content list should be part of the Signature Input, to protect against malicious changes.</t>
                </section>

                <section>
                    <name>Algorithm is not signed</name>
                    <t>The Algorithm should be part of the Signature Input, to protect against malicious changes.</t>
                </section>

                <section>
                    <name>Verification key identifier is not signed</name>
                    <t>The Verification key identifier (e.g., the value used for the <tt>keyId</tt> parameter) should be part of the Signature Input, to protect against malicious changes.</t>
                </section>

                <section>
                    <name>Max values, precision for Integer String and Decimal String not defined</name>
                    <t>The definitions for Integer String and Decimal String do not specify a maximum value.  The definition for Decimal String (used to provide sub-second precision for Expiration Time) does not define minimum or maximum precision requirements.  It should set a sane requirement here (e.g., MUST support up to 3 decimal places and no more).</t>
                </section>

                <section>
                    <name><tt>keyId</tt> parameter value could break list syntax</name>
                    <t>The <tt>keyId</tt> parameter value needs to be constrained so as to not break list syntax (e.g., by containing a comma).</t>
                </section>

                <section>
                    <name>Creation Time and Expiration Time do not allow for clock skew</name>
                    <t>The processing instructions for Creation Time and Expiration Time imply that verifiers are not permitted to account for clock skew during signature verification.</t>
                </section>

                <section>
                    <name>Should require lowercased header field names as identifiers</name>
                    <t>The current text allows mixed-case header field names when they are being used as content identifiers.  This is unnecessary, as header field names are case-insensitive, and creates opportunity for incompatibility.  Instead, content identifiers should always be lowercase.</t>
                </section>

                <section>
                    <name>Reconcile Date header and Creation Time</name>
                    <t>The draft is missing guidance on if/how the Date header relates to signature Creation Time.  There are cases where they may be different, such as if a signature was pre-created.  Should Creation Time default to the value in the Date header if the <tt>created</tt> parameter is not specified?  </t>
                </section>

                <section>
                    <name>Remove algorithm-specific rules for content identifiers</name>
                    <t>The rules that restrict when the signer can or must include certain identifiers appear to be related to the pseudo-revving of the Cavage draft that happened when the <tt>hs2019</tt> algorithm was introduced.  We should drop these rules, as it can be expected that anyone implementing this draft will support all content identifiers.</t>
                </section>

                <section>
                    <name>Add guidance for signing compressed headers</name>
                    <t>The draft should provide guidance on how to sign headers when <xref target="RFC7541">HTTP/2 header compression</xref> is used.  This guidance might be as simple as "sign the uncompressed header field value."</t>
                </section>


                <section>
                    <name>Transformations to Via header field value break verification</name>
                    <t>Intermediaries are permitted to strip comments from the Via header field value, and consolidate related sequences of entries.  The canonicalization rules do not account for these changes, and thus they cause signature verification to fail if the Via header is signed.</t>
                </section>

                <section>
                    <name>Case changes to case-insensitive header field values break verification</name>
                    <t>Some header field values are case-insensitive, in whole or in part. The canonicalization rules do not account for this, thus a case change to a covered header field value causes verification to fail.</t>
                </section>

                <section>
                    <name>Need more examples for Signature header</name>
                    <t>Add more examples showing different cases e.g, where <tt>created</tt> or <tt>expires</tt> are not present.</t>
                </section>
            </section>

            <section>
                <name>Features</name>
                <section>
                    <name>Define more content identifiers</name>
                    <t keepWithNext="true">It should be possible to independently include the following content and metadata properties in Covered Content:</t>
                    <ul>
                        <li>The signature's Algorithm</li>
                        <li>The signature's Covered Content</li>
                        <li>The value used for the <tt>keyId</tt> parameter</li>
                        <li>Request method</li>
                        <li>Individual components of the effective request URI: scheme, authority, path, query</li>
                        <li>Status code</li>
                    </ul>
                </section>

                <section>
                    <name>Multiple signature support</name>
                    <t>[[ Editor's note: I believe this use case is theoretical.  Please let me know if this is a use case you have. ]]</t>

                    <t keepWithNext="true">There may be scenarios where attaching multiple signatures to a single message is useful:</t>
                    <ul>
                        <li>A gateway attaches a signature over headers it adds (e.g., Forwarded) to messages already signed by the user agent.</li>
                        <li>A signer attaches two signatures signed by different keys, to be verified by different entities.</li>
                    </ul>

                    <t>This could be addressed by changing the Signature header syntax to accept a list of parameter sets for a single signature, e.g., by separating parameters with <tt>";"</tt> instead of <tt>","</tt>.  It may also be necessary to include a signature identifier parameter.</t>
                </section>

                <section>
                    <name>Support for incremental signing of header field value list items</name>
                    <t>[[ Editor's note: I believe this use case is theoretical.  Please let me know if this is a use case you have. ]]</t>

                    <t>Currently, signing a header field value is all-or-nothing: either the entire value is signed, or none of it is.  For header fields that use list syntax, it would be useful to be able to specify which items in the list are signed.</t>
                    
                    <t>A simple approach that allowed the signer to indicate the list size at signing time would allow a signer to sign header fields that are may be appended to by intermediaries as the message makes its way to the recipient.  Specifying list size in terms of number of items could introduce risks of list syntax is not strictly adhered to (e.g., a malicious party crafts a value that gets parsed by the application as 5 items, but by the verifier as 4).  Specifying list size in number of octets might address this, but more exploration is required.</t>
                </section>

                <section>
                    <name>Support expected authority changes</name>
                    <t>In some cases, the authority of the effective request URI may be expected to change, for example from "public-service-name.example.com" to "service-host-1.public-service-name.example.com".  This is commonly the case for services that are hosted behind a load-balancing gateway, where the client sends requests to a publicly known domain name for the service, and these requests are transformed by the gateway into requests to specific hosts in the service fleet.</t>
                    <t>One possible way to handle this would be to special-case the Host header field to allow verifier to substitute a known expected value, or a value provided in another header field (e.g., Via) when generating the Signature Input, provided that the verifier also recognizes the real value in the Host header.  Alternatively, this logic could apply to an <tt>(audience)</tt> content identifier.</t>
                </section>

                <section>
                    <name>Support for signing specific cookies</name>
                    <t>A signer may only wish to sign one or a few cookies, for example if the website requires its authentication state cookie to be signed, but also sets other cookies (e.g., for analytics, ad tracking, etc.)</t>
                </section>
            </section>
        </section>

        <section anchor="acknowledgements" numbered="false">
            <name>Acknowledgements</name>
            <t>This specification is based on the draft-cavage-http-signatures draft.  The editor would like to thank the authors of that draft, Mark Cavage and Manu Sporny, for their work on that draft and their continuing contributions.</t>
            <t>The editor would also like to thank the following individuals for feedback on and implementations of the draft-cavage-http-signatures draft (in alphabetical order):
Mark Adamcin,
Mark Allen,
Paul Annesley,
Karl BÃ¶hlmark,
StÃ©phane Bortzmeyer,
Sarven Capadisli,
Liam Dennehy,
ductm54,
Stephen Farrell,
Phillip Hallam-Baker,
Eric Holmes,
Andrey Kislyuk,
Adam Knight,
Dave Lehn,
Dave Longley,
James H. Manger,
Ilari Liusvaara,
Mark Nottingham,
Yoav Nir,
Adrian Palmer,
Lucas Pardue,
Roberto Polli,
Julian Reschke,
Michael Richardson,
Wojciech Rygielski,
Adam Scarr,
Cory J. Slep,
Dirk Stein,
Henry Story,
Lukasz Szewc,
Chris Webber, and
Jeffrey Yasskin
            </t>
        </section>

        <section numbered="false" removeInRFC="true">
            <name>Document History</name>
            <ul>
                <li>
                    <t><strong>draft-richanna-http-message-signatures</strong></t>
                    <ul>
                        <li>
                            <t><strong>-00</strong></t>
                            <ul>
                                <li>Converted to xml2rfc v3 and reformatted to comply with RFC style guides.</li>
                                <li>Rewrote abstract and introduction to focus on general purpose signing and avoid specific use cases.</li>
                                <li>Added intro sections on challenges with HTTP message signing, and listing innocuous transformations that the signing mechanism must tolerate.</li>
                                <li>Added Document History section.</li>
                                <li>Removed informative intro sections on Signatures in HTTP Requests/Responses, as they imply specific use cases.</li>
                                <li>Moved BCP 14 message under intro section.</li>
                                <li>Removed <tt>Signature</tt> auth-scheme definition and non-normative description of using the <tt>Signature</tt> header field for authentication.</li>
                                <li>Removed "Canonicalization Algorithm" from HTTP Signature Algorithms registry entries.</li>
                                <li>Replaced mentions of ANSI X9.64 with normative references to FIPS 186-4.</li>
                                <li>Combined HTTP Signature Algorithms registry entry algorithm fields into a "Description" field.</li>
                                <li>Revised HTTP Signature Algorithms registry definition.  Added change control policy and registry template.  Removed suggested URI.</li>
                                <li>Moved normative text related to ambiguous signature parameters to Signature header definition.</li>
                                <li>Added normative reference to RFC 2104 for HMAC.</li>
                                <li>Added informative reference to RFC 3339.</li>
                                <li>Added normative reference to POSIX.1 in `created` and `expires` parameter definitions.</li>
                                <li>Added definitions for HTTP-related terms by referencing RFC 7230.</li>
                                <li>Added definitions for Signer and Verifier, and placeholder entries for Signing Algorithm and Signing String.</li>
                                <li>Added definition of signature as applying to both digital signatures and MACs.</li>
                                <li>Renamed The Components of a Signature to HTTP Message Signatures. Revised to define message signatures without reference to Authorization or Signature headers.</li>
                                <li>Added Signature Metadata section.  Moved normative requirements in Signature Parameters out to appropriate places (e.g., signature creation), redefined parameters in terms of metadata properties, and moved them to Signature header section.</li>
                                <li>Dropped definitions for unused terms Signing Algorithm and Signing String</li>
                                <li>Moved metadata expressions to canonicalization section.</li>
                                <li>Added detailed description of signature generation and verification process.</li>
                                <li>Removed duplication of normative requirements, consolidated requirements for generation and verification to their respective sections.</li>
                                <li>Replaced Key Reference metadata property with Verification Key Material.</li>
                                <li>Removed conflicting normative requirements for use of <tt>algorithm</tt> parameter. Now <bcp14>MUST NOT</bcp14> be relied upon.</li>
                                <li>Moved Content Identifiers up to its own top-level section.</li>
                                <li>Explicitly defined Integer String and Decimal String.</li>
                                <li>Consolidated content identifiers and canonicalization rules into a single section.</li>
                                <li>Added examples for header field and <tt>(request-target)</tt> canonicalization.</li>
                                <li>Removed Extensions appendix and fixed keys and signatures on test examples.</li>
                                <li>Revised introduction around need for non-TLS integrity/authenticity protection. Added Requirements Description.</li>
                                <li>Revised Signature header definition.</li>
                                <li>Added Topics for Working Group Discussion section, to be removed prior to publication as an RFC.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </section>
    </back>
</rfc>
