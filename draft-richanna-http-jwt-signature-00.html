<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Signing HTTP Requests via JSON Web Signatures </title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology">
<link href="#rfc.section.3" rel="Chapter" title="3 Generating a HTTP Request Signature Using JWS">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Generating the Payload of the JWS">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Calculating the query parameter list and hash">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Calculating the header list and hash">
<link href="#rfc.section.4" rel="Chapter" title="4 Validating the HTTP Message Signature">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Validating the query parameter list and hash">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Validating the header list and hash">
<link href="#rfc.section.5" rel="Chapter" title="5 IANA Considerations">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 JSON Web Signature and Encryption Type Values Registration">
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Offering Confidentiality Protection for Access to Protected Resources">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Plaintext Storage of Credentials">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Entropy of Keys">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Denial of Service">
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 Validating the integrity of HTTP message">
<link href="#rfc.section.7" rel="Chapter" title="7 Privacy Considerations">
<link href="#rfc.section.8" rel="Chapter" title="8 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="9 Normative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.17.1 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Backman, A., Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-http-request-signing-jws-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-11-06" />
  <meta name="dct.abstract" content="This document defines a method for generating and validating a digital signature or Message Authentication Code (MAC) over a set of protocol elements within an HTTP Request, using JSON Web Signatures (JWS)." />
  <meta name="description" content="This document defines a method for generating and validating a digital signature or Message Authentication Code (MAC) over a set of protocol elements within an HTTP Request, using JSON Web Signatures (JWS)." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">A. Backman, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Amazon</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">November 06, 2019</td>
</tr>
<tr>
<td class="left">Expires: May 9, 2020</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Signing HTTP Requests via JSON Web Signatures <br />
  <span class="filename">draft-ietf-http-request-signing-jws-00</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document defines a method for generating and validating a digital signature or Message Authentication Code (MAC) over a set of protocol elements within an HTTP Request, using JSON Web Signatures (JWS).</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on May 9, 2020.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Terminology</a>
</li>
<li>3.   <a href="#rfc.section.3">Generating a HTTP Request Signature Using JWS</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Generating the Payload of the JWS</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Calculating the query parameter list and hash</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Calculating the header list and hash</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Validating the HTTP Message Signature</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Validating the query parameter list and hash</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Validating the header list and hash</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">IANA Considerations</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">JSON Web Signature and Encryption Type Values Registration</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">Security Considerations</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Offering Confidentiality Protection for Access to Protected Resources</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Plaintext Storage of Credentials</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Entropy of Keys</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">Denial of Service</a>
</li>
<li>6.5.   <a href="#rfc.section.6.5">Validating the integrity of HTTP message</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Privacy Considerations</a>
</li>
<li>8.   <a href="#rfc.section.8">Acknowledgements</a>
</li>
<li>9.   <a href="#rfc.references">Normative References</a>
</li>
<li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">Furthermore, it is desirable to bind the signature to the HTTP request. Ideally, this should be done without replicating the information already present in the HTTP request more than required.  However, many HTTP application frameworks insert extra headers, query parameters, and otherwise manipulate the HTTP request on its way from the web server into the application code itself. It is the goal of this draft to have a signature protection mechanism that is sufficiently robust against such deployment constraints while still providing sufficient security benefits.</p>
<p id="rfc.section.1.p.2">The key required for this signature calculation is distributed via mechanisms described in companion documents (see <a href="#I-D.ietf-oauth-pop-key-distribution" class="xref">[I-D.ietf-oauth-pop-key-distribution]</a> and <a href="#I-D.ietf-oauth-pop-architecture" class="xref">[I-D.ietf-oauth-pop-architecture]</a>). The JSON Web Signature (JWS) specification <a href="#RFC7515" class="xref">[RFC7515]</a> is used for computing a digital signature (which uses asymmetric cryptography) or a keyed message digest (in case of symmetric cryptography).</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Terminology</h1>
<p id="rfc.section.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119" class="xref">RFC 2119</a>.</p>
<p id="rfc.section.2.p.2">Other terms such as "client", "server", "HTTP request", and "protocol element" are inherited from <a href="#RFC7230" class="xref">HTTP</a>.</p>
<p id="rfc.section.2.p.3">This document uses the term 'sign' (or 'signature') to denote both a keyed message digest and a digital signature operation.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> Generating a HTTP Request Signature Using JWS</h1>
<p id="rfc.section.3.p.1">This specification uses JSON Web Signature <a href="#RFC7515" class="xref">[RFC7515]</a> to sign a subset of protocol elements taken from an HTTP Request. When a JWS is created for this purpose, its <samp>"typ"</samp> header attribute MUST have the value <samp>"http-sig"</samp>.</p>
<p id="rfc.section.3.p.2">The JWS MUST be signed with a valid algorithm as defined in <a href="#RFC7518" class="xref">[RFC7518]</a>.  The <samp>none</samp> algorithm MUST NOT be used.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> Generating the Payload of the JWS</h1>
<p id="rfc.section.3.1.p.1">The JWS Payload is a JSON object containing the data that will be covered by the signature.  In order to include a protocol element within the covered data, its value must be represented within this JSON object. Some elements are represented directly, by setting the value of a member in the object to the element's value in the HTTP Request. Others are included indirectly, by setting the value of a member in the object to a cryptographic hash or other value derived from the element's value in the HTTP Request.</p>
<p id="rfc.section.3.1.p.2">The below list defines the means of inclusion of various protocol elements, including the JSON object member that MUST be used when including the element, and how the element's value should be included. When present, each of these members MUST be a top-level member of the JSON object.</p>
<p id="rfc.section.3.1.p.3">The JSON object MAY contain other top-level members. The syntax and semantics of members not listed below are out of scope of this specification. Implementations SHOULD consider a signature invalid if the JSON object contains members that the implementation does not understand.</p>
<p></p>

<dl>
<dt>ts</dt>
<dd style="margin-left: 8">RECOMMENDED. The timestamp. This integer provides replay protection of the signed JSON object. Its value MUST be a number containing an integer value representing number of whole integer seconds from midnight, January 1, 1970 GMT.</dd>
<dt>m</dt>
<dd style="margin-left: 8">OPTIONAL. The HTTP Method used to make this request.  This MUST be the uppercase HTTP verb as a JSON string.</dd>
<dt>u</dt>
<dd style="margin-left: 8">OPTIONAL. The HTTP URL host component as a JSON string. This MAY include the port separated from the host by a colon in host:port format.</dd>
<dt>p</dt>
<dd style="margin-left: 8">OPTIONAL. The HTTP URL path component of the request as an HTTP string.</dd>
<dt>q</dt>
<dd style="margin-left: 8">OPTIONAL. The hashed HTTP URL query parameter map of the request as a two-part JSON array. The first part of this array is a JSON array listing all query parameters that were used in the calculation of the hash in the order that they were added to the hashed value as described below. The second part of this array is a JSON string containing the Base64URL encoded hash itself, calculated as described below.</dd>
<dt>h</dt>
<dd style="margin-left: 8">OPTIONAL. The hashed HTTP request headers as a two-part JSON array. The first part of this array is a JSON array listing all headers that were used in the calculation of the hash in the order that they were added to the hashed value as described below. The second part of this array is a JSON string containing the Base64URL encoded hash itself, calculated as described below.</dd>
<dt>b</dt>
<dd style="margin-left: 8">OPTIONAL. The base64URL encoded hash of the HTTP Request body, calculated as the SHA256 of the byte array of the body</dd>
</dl>
<p id="rfc.section.3.1.p.5">All hashes SHALL be calculated using the SHA256 algorithm.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> Calculating the query parameter list and hash</h1>
<p id="rfc.section.3.2.p.1">To generate the query parameter list and hash, the signer creates two data objects: an ordered list of strings to hold the query parameter names and a string buffer to hold the data to be hashed.</p>
<p id="rfc.section.3.2.p.2">The signer iterates through all query parameters in whatever order it chooses and for each query parameter it does the following:</p>
<p></p>

<ol>
<li>Adds the name of the query parameter to the end of the list.</li>
<li>Percent-encodes the name and value of the parameter as specified in <a href="#RFC3986" class="xref">[RFC3986]</a>. Note that if the name and value have already been percent-encoded for transit, they are not re-encoded for this step.</li>
<li>Encodes the name and value of the query parameter as "name=value" and appends it to the string buffer separated by the ampersand <samp>&amp;</samp> character.</li>
</ol>

<p>Repeated parameter names are processed separately with no special handling. Parameters MAY be skipped by the client if they are not required (or desired) to be covered by the signature.</p>
<p id="rfc.section.3.2.p.4">The signer then calculates the hash over the resulting string buffer. The list and the hash result are added to a list as the value of the "q" member.</p>
<p id="rfc.section.3.2.p.5">For example, the query parameter set of "b=bar", "a=foo", "c=duck" is concatenated into the string:</p>
<pre>b=bar&amp;a=foo&amp;c=duck</pre>
<p id="rfc.section.3.2.p.6">When added to the JSON structure using this process, the results are:</p>
<pre>"q": [["b", "a", "c"], "u4LgkGUWhP9MsKrEjA4dizIllDXluDku6ZqCeyuR-JY"]</pre>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> Calculating the header list and hash</h1>
<p id="rfc.section.3.3.p.1">To generate the header list and hash, the signer creates two data objects: an ordered list of strings to hold the header names and a string buffer to hold the data to be hashed.</p>
<p id="rfc.section.3.3.p.2">The signer iterates through all query parameters in whatever order it chooses and for each query parameter it does the following:</p>
<p></p>

<ol>
<li>Lowercases the header name.</li>
<li>Adds the name of the header to the end of the list.</li>
<li>Encodes the name and value of the header as "name: value" and appends it to the string buffer separated by a newline <samp>\n</samp> character.</li>
</ol>

<p>Repeated header names are processed separately with no special handling. Headers MAY be skipped by the client if they are not required (or desired) to be covered by the signature.</p>
<p id="rfc.section.3.3.p.4">The signer then calculates the hash over the resulting string buffer. The list and the hash result are added to a list as the value of the "h" member.</p>
<p id="rfc.section.3.3.p.5">For example, the headers "Content-Type: application/json" and "Etag: 742-3u8f34-3r2nvv3" are concatenated into the string:</p>
<pre>content-type: application/json
etag: 742-3u8f34-3r2nvv3</pre>
<pre>"h": [["content-type", "etag"], 
  "bZA981YJBrPlIzOvplbu3e7ueREXXr38vSkxIBYOaxI"]</pre>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> Validating the HTTP Message Signature</h1>
<p id="rfc.section.4.p.1">Validation of the signature is done using normal JWS validation for the signature and key type. Additionally, in order to trust any of the hashed components of the HTTP request, the validator MUST re-create and verify a hash for each component as described below. This process is a mirror of the process used to create the hashes in the first place, with a mind toward the fact that order may have changed and that elements may have been added or deleted. The protected resource MUST similarly compare the replicated values included in various JSON fields with the corresponding actual values from the request. Failure to do so will allow an attacker to modify the underlying request while at the same time having the application layer verify the signature correctly.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> Validating the query parameter list and hash</h1>
<p id="rfc.section.4.1.p.1">The validator has at its disposal a map that indexes the query parameter names to the values given. The validator creates a string buffer for calculating the hash. The validator then iterates through the "list" portion of the "p" parameter. For each item in the list (in the order of the list) it does the following:</p>
<p></p>

<ol>
<li>Fetch the value of the parameter from the HTTP request query parameter map. If a parameter is found in the list of signed parameters but not in the map, the validation fails.</li>
<li>Percent-encodes the name and value of the parameter as specified in <a href="#RFC3986" class="xref">[RFC3986]</a>. Note that if the name and value have already been percent-encoded for transit, they are not re-encoded for this step.</li>
<li>Encode the parameter as "name=value" and concatenate it to the end of the string buffer, separated by an ampersand character.</li>
</ol>
<p id="rfc.section.4.1.p.3">The validator calculates the hash of the string buffer and base64url encodes it. The protected resource compares that string to the string passed in as the hash. If the two match, the hash validates, and all named parameters and their values are considered covered by the signature.</p>
<p id="rfc.section.4.1.p.4">There MAY be additional query parameters that are not listed in the list and are therefore not covered by the signature. The validator MUST decide whether or not to accept a request with these uncovered parameters.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> Validating the header list and hash</h1>
<p id="rfc.section.4.2.p.1">The validator has at its disposal a map that indexes the header names to the values given. The validator creates a string buffer for calculating the hash. The validator then iterates through the "list" portion of the "h" parameter. For each item in the list (in the order of the list) it does the following:</p>
<p></p>

<ol>
<li>Fetch the value of the header from the HTTP request header map.  If a header is found in the list of signed parameters but not in the map, the validation fails.</li>
<li>Encode the parameter as "name: value" and concatenate it to the end of the string buffer, separated by a newline character.</li>
</ol>
<p id="rfc.section.4.2.p.3">The validator calculates the hash of the string buffer and base64url encodes it. The protected resource compares that string to the string passed in as the hash. If the two match, the hash validates, and all named headers and their values are considered covered by the signature.</p>
<p id="rfc.section.4.2.p.4">There MAY be additional headers that are not listed in the list and are therefore not covered by the signature. The validator MUST decide whether or not to accept a request with these uncovered headers.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#IANA" id="IANA">IANA Considerations</a>
</h1>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> JSON Web Signature and Encryption Type Values Registration</h1>
<p id="rfc.section.5.1.p.1">This specification registers the <samp>http-sig</samp> type value in the IANA JSON Web Signature and Encryption Type Values registry <a href="#RFC7515" class="xref">[RFC7515]</a>: </p>

<ul>
<li>"typ" Header Parameter Value: <samp>http-sig</samp>
</li>
<li>Abbreviation for MIME Type: None</li>
<li>Change Controller: IETF</li>
<li>Specification Document(s): [[ this document ]]</li>
</ul>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#Security" id="Security">Security Considerations</a>
</h1>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> Offering Confidentiality Protection for Access to Protected Resources</h1>
<p id="rfc.section.6.1.p.1">This specification can be used with and without Transport Layer Security (TLS).</p>
<p id="rfc.section.6.1.p.2">Without TLS this protocol provides a mechanism for verifying the integrity of requests, it provides no confidentiality protection.  Consequently, eavesdroppers will have full access to communication content and any further messages exchanged between the client and the server. This could be problematic when data is exchanged that requires care, such as personal data.</p>
<p id="rfc.section.6.1.p.3">When TLS is used then confidentiality of the transmission can be ensured between endpoints, including both the request and the response. The use of TLS in combination with the signed HTTP request mechanism is highly recommended to ensure the confidentiality of the data returned from the protected resource.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> Plaintext Storage of Credentials</h1>
<p id="rfc.section.6.2.p.1">The mechanism described in this document works in a similar way to many three-party authentication and key exchange mechanisms. In order to compute the signature over the HTTP request, the client must have access to the decryption key in plaintext form. If an attacker were to gain access to these stored secrets at the client or (in case of symmetric keys) at the server they would be able to forge signatures for any HTTP request they wished, effectively allowing them to impersonate the client.</p>
<p id="rfc.section.6.2.p.2">It is therefore paramount to the security of the protocol that any private or symmetric keys used to sign HTTP requests are protected from unauthorized access.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> Entropy of Keys</h1>
<p id="rfc.section.6.3.p.1">Unless TLS is used between the client and the resource server, eavesdroppers will have full access to requests sent by the client.  They will thus be able to mount off-line brute-force attacks to attempt recovery of the session key or private key used to compute the keyed message digest or digital signature, respectively.</p>
<p id="rfc.section.6.3.p.2">Key generation and distribution is out of scope for this document.  It is the responsibility of users of this specification to ensure that keys are generated with sufficient entropy and rotated at an appropriate frequency to sufficiently mitigate the risk of such attacks, as appropriate for their use case.</p>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> Denial of Service</h1>
<p id="rfc.section.6.4.p.1">This specification includes a number of features which may make resource exhaustion attacks against servers possible. For example, server may need to consult back-end databases or other servers in order to verify a signature, or the cryptographic overhead may present a significant burden on the server. An attacker could leverage this overhead to attempt a denial of service attack by sending a large number of invalid requests to the server, causing the server to expend significant resources checking invalid signatures. This attack vector must be taken into consideration when implementing or deploying this specification.</p>
<h1 id="rfc.section.6.5">
<a href="#rfc.section.6.5">6.5.</a> Validating the integrity of HTTP message</h1>
<p id="rfc.section.6.5.p.1">This specification provides flexibility for selectively validating the integrity of the HTTP request, including header fields, query parameters, and message bodies. Since all components of the HTTP request are only optionally validated by this method, and even some components may be validated only in part (e.g., some headers but not others) it is up to developers to verify that any vital parameters in a request are actually covered by the signature. Failure to do so could allow an attacker to inject vital parameters or headers into the request, ouside of the protection of the signature.</p>
<p id="rfc.section.6.5.p.2">The application verifying this signature MUST NOT assume that any particular parameter is appropriately covered by the signature unless it is included in the signed structure and the hash is verified. Any applications that are sensitive of header or query parameter order MUST verify the order of the parameters on their own. The application MUST also compare the values in the JSON container with the actual parameters received with the HTTP request (using a direct comparison or a hash calculation, as appropriate). Failure to make this comparison will render the signature mechanism useless for protecting these elements.</p>
<p id="rfc.section.6.5.p.3">The behavior of repeated query parameters or repeated HTTP headers is undefined by this specification. If a header or query parameter is repeated on either the outgoing request from the client or the incoming request to the protected resource, that query parameter or header name MUST NOT be covered by the hash and signature.</p>
<p id="rfc.section.6.5.p.4">This specification records the order in which query parameters and headers are hashed, but it does not guarantee that order is preserved between the client and protected resource. If the order of parameters or headers are significant to the underlying application, it MUST confirm their order on its own, apart from the signature and HTTP message validation.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> Privacy Considerations</h1>
<p id="rfc.section.7.p.1">This specification addresses machine to machine communications and raises no privacy considerations beyond existing HTTP interactions.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#Acknowledgements" id="Acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.8.p.1">The authors thank the OAuth Working Group for input into this work.</p>
<p id="rfc.section.8.p.2">In particular, the authors thank Justin Richer for his work on <a href="#I-D.ietf-oauth-signed-http-request" class="xref">[I-D.ietf-oauth-signed-http-request]</a>, on which this specification is based.</p>
<h1 id="rfc.references">
<a href="#rfc.references">9.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-oauth-pop-architecture">[I-D.ietf-oauth-pop-architecture]</b></td>
<td class="top">
<a>Hunt, P.</a>, <a>Richer, J.</a>, <a>Mills, W.</a>, <a>Mishra, P.</a> and <a>H. Tschofenig</a>, "<a href="https://tools.ietf.org/html/draft-ietf-oauth-pop-architecture-08">OAuth 2.0 Proof-of-Possession (PoP) Security Architecture</a>", Internet-Draft draft-ietf-oauth-pop-architecture-08, July 2016.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-oauth-pop-key-distribution">[I-D.ietf-oauth-pop-key-distribution]</b></td>
<td class="top">
<a>Bradley, J.</a>, <a>Hunt, P.</a>, <a>Jones, M.</a>, <a>Tschofenig, H.</a> and <a>M. Meszaros</a>, "<a href="https://tools.ietf.org/html/draft-ietf-oauth-pop-key-distribution-07">OAuth 2.0 Proof-of-Possession: Authorization Server to Client Key Distribution</a>", Internet-Draft draft-ietf-oauth-pop-key-distribution-07, March 2019.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-oauth-signed-http-request">[I-D.ietf-oauth-signed-http-request]</b></td>
<td class="top">
<a>Richer, J.</a>, <a>Bradley, J.</a> and <a>H. Tschofenig</a>, "<a href="https://tools.ietf.org/html/draft-ietf-oauth-signed-http-request-03">A Method for Signing HTTP Requests for OAuth</a>", Internet-Draft draft-ietf-oauth-signed-http-request-03, August 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3986">[RFC3986]</b></td>
<td class="top">
<a>Berners-Lee, T.</a>, <a>Fielding, R.</a> and <a>L. Masinter</a>, "<a href="https://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7230">[RFC7230]</b></td>
<td class="top">
<a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7515">[RFC7515]</b></td>
<td class="top">
<a>Jones, M.</a>, <a>Bradley, J.</a> and <a>N. Sakimura</a>, "<a href="https://tools.ietf.org/html/rfc7515">JSON Web Signature (JWS)</a>", RFC 7515, DOI 10.17487/RFC7515, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7518">[RFC7518]</b></td>
<td class="top">
<a>Jones, M.</a>, "<a href="https://tools.ietf.org/html/rfc7518">JSON Web Algorithms (JWA)</a>", RFC 7518, DOI 10.17487/RFC7518, May 2015.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Annabelle Backman</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Backman</span>
	  </span>
	</span>
	<span class="org vcardline">Amazon</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:richanna@amazon.com">richanna@amazon.com</a></span>

  </address>
</div>

</body>
</html>
